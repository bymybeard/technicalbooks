<HTML>
<HEAD>
<TITLE>Teach Yourself Java in 21 Days tyj19x.htm</TITLE>
<LINK REL="ToC" HREF="httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html">
<LINK REL="Index" HREF="htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html">
<LINK REL="Next" HREF="tyj20x.html" tppabs="http://newdata.box.sk/bx/java/tyj20x.html">
<LINK REL="Previous" HREF="tyj18x.html" tppabs="http://newdata.box.sk/bx/java/tyj18x.html"></HEAD>
<BODY TEXT="#000000" LINK="#0000FF" VLINK="#800080" BACKGROUND="yellzig.gif" tppabs="http://newdata.box.sk/bx/java/yellzig.gif">

<P><A HREF = "tyj18x.html" tppabs="http://newdata.box.sk/bx/java/tyj18x.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="blutoc.gif" tppabs="http://newdata.box.sk/bx/java/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF = "htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html"  ><IMG SRC="bluindex.gif" tppabs="http://newdata.box.sk/bx/java/bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF = "tyj20x.html" tppabs="http://newdata.box.sk/bx/java/tyj20x.html"  ><IMG SRC="blunext.gif" tppabs="http://newdata.box.sk/bx/java/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>
</P><UL>
<LI>
<A HREF = "#I1"  >Day 19</A></LI>
<UL>
<LI>
<A HREF = "#I3"  >Streams</A></LI>
<UL>
<LI>
<A HREF = "#I9"  >Input Streams</A></LI>
<UL>
<LI>
<A HREF = "#I12"  >The abstract Class InputStream</A></LI>
<UL>
<LI>
<A HREF = "#I16"  >read()</A></LI>
<LI>
<A HREF = "#I25"  >skip()</A></LI>
<LI>
<A HREF = "#I30"  >available()</A></LI>
<LI>
<A HREF = "#I33"  >mark() and reset()</A></LI>
<LI>
<A HREF = "#I44"  >close()</A></LI></UL>
<LI>
<A HREF = "#I47"  >ByteArrayInputStream</A></LI>
<LI>
<A HREF = "#I55"  >FileInputStream</A></LI>
<LI>
<A HREF = "#I68"  >FilterInputStream</A></LI>
<UL>
<LI>
<A HREF = "#I75"  >BufferedInputStream</A></LI>
<LI>
<A HREF = "#I78"  >DataInputStream</A></LI>
<LI>
<A HREF = "#I86"  >LineNumberInputStream</A></LI>
<LI>
<A HREF = "#I91"  >PushbackInputStream</A></LI></UL>
<LI>
<A HREF = "#I96"  >PipedInputStream</A></LI>
<LI>
<A HREF = "#I99"  >SequenceInputStream</A></LI>
<LI>
<A HREF = "#I106"  >StringBufferInputStream</A></LI></UL>
<LI>
<A HREF = "#I109"  >Output Streams</A></LI>
<UL>
<LI>
<A HREF = "#I112"  >The abstract Class OutputStream</A></LI>
<UL>
<LI>
<A HREF = "#I116"  >write()</A></LI>
<LI>
<A HREF = "#I121"  >flush()</A></LI>
<LI>
<A HREF = "#I127"  >close()</A></LI></UL>
<LI>
<A HREF = "#I133"  >ByteArrayOutputStream</A></LI>
<LI>
<A HREF = "#I142"  >FileOutputStream</A></LI>
<LI>
<A HREF = "#I147"  >FilterOutputStream</A></LI>
<UL>
<LI>
<A HREF = "#I151"  >BufferedOutputStream</A></LI>
<LI>
<A HREF = "#I154"  >DataOutputStream</A></LI>
<LI>
<A HREF = "#I164"  >PrintStream</A></LI></UL>
<LI>
<A HREF = "#I167"  >PipedOutputStream</A></LI></UL>
<LI>
<A HREF = "#I170"  >Related Classes</A></LI>
<LI>
<A HREF = "#I177"  >Summary</A></LI>
<LI>
<A HREF = "#I178"  >Q&amp;A</A></LI></UL></UL></UL>

<H1><A ID = "I1" NAME = "I1"  >
<BR>
<foNT SIZE=5><A ID = "I2" NAME = "I2"  ></A><B>Day 19</B>
<BR></FONT></A></H1>
<H2><A ID = "I3" NAME = "I3"  >
<foNT SIZE=5><B>Streams</B>
<BR></FONT></A></H2>
<P><B>by Charles L. Perkins</B>
<BR></P>
<P>Today, you'll explore Java's streams:
<BR></P>
<UL>
<LI>Input streams&#151;and how to create, use, and detect the end of them&#151;and filtered input streams, which can be nested to great effect
<BR>
<BR></LI>
<LI>Output streams, that are mostly analogous to (but the inverse of) input streams
<BR>
<BR></LI></UL>
<P>You'll also learn about two stream interfaces that make the reading and writing of typed streams much easier (as well as about several utility classes used to access the file system). Let's begin with a little history behind the invention of streams.
<BR></P>
<P>A <I>pipe </I>is an uninterpreted <A ID = "I4" NAME = "I4"  ></A>stream of bytes that can be used for communicating between programs (or other &quot;forked&quot; copies of your own program) or for reading and writing to arbitrary peripheral devices and files.
<BR></P>
<P>One of the early inventions of the UNIX operating system was the pipe. By unifying many disparate ways of communicating into a single metaphor, UNIX paved the way for a whole series of related inventions, culminating in the abstraction known as streams.
<BR></P>
<P>A <I>stream</I> is a path <A ID = "I5" NAME = "I5"  ></A>of communication between the source of some information and its destination. 
<BR></P>
<P>This information, an uninterpreted byte stream, can come from any &quot;pipe source,&quot; the computer's memory, or even from the Internet. In fact, the source and destination of a stream are completely arbitrary producers and consumers of bytes, respectively. Therein lies the power of the abstraction. You don't need to know about the source of the information when reading from a stream, and you don't need to know about the final destination when writing to one.
<BR></P>
<P>General-purpose methods that can read from any source accept a stream argument to specify that source; general methods for writing accept a stream to specify the destination. Arbitrary <I>processors</I> (or <I>filters</I>) of data <A ID = "I6" NAME = "I6"  ></A><A ID = "I7" NAME = "I7"  ></A><A ID = "I8" NAME = "I8"  ></A>have two stream arguments. They read from the first, process the data, and write the results to the second. These processors have no idea of either the source <I>or</I> the destination of the data they are processing. Sources and destinations can vary widely: from two memory buffers on the same local computer, to the ELF transmissions to and from a submarine at sea, to the real-time data streams of a NASA probe in deep space.
<BR></P>
<P>By decoupling the consuming, processing, or producing of data from the sources and destinations of that data, you can mix and match any combination of them at will as you write your program. In the future, when new, previously nonexistent forms of source or destination (or consumer, processor, or producer) appear, they can be used within the same framework, with no changes to your classes. In addition, new stream abstractions, supporting higher levels of interpretation &quot;on top of&quot; the bytes, can be written completely independently of the underlying transport mechanisms for the bytes themselves.
<BR></P>
<P>The foundations of this stream framework are the two abstract classes, InputStream and OutputStream. If you turn briefly to the diagram for java.io in Appendix B, you'll see that below these classes is a virtual cornucopia of categorized classes, demonstrating the wide range of streams in the system, but also demonstrating an extremely well-designed hierarchy of relationships between these streams, one well worth learning from. Let's begin with the parents and then work our way down this bushy tree.
<BR></P>
<H3><A ID = "I9" NAME = "I9"  >
<foNT SIZE=4><B>Input Streams</B>
<BR></FONT></A></H3>
<P>All the methods <A ID = "I10" NAME = "I10"  ></A><A ID = "I11" NAME = "I11"  ></A>you will explore today are declared to throw IOExceptions. This new subclass of Exception conceptually embodies all the possible I/O errors that might occur while using streams. Several subclasses of it define a few, more specific exceptions that can be thrown as well. For now, it is enough to know that you must either catch an IOException, or be in a method that can &quot;pass it along,&quot; to be a well-behaved user of streams.
<BR></P>
<H4><A ID = "I12" NAME = "I12"  >
<foNT SIZE=3><B>The abstract Class InputStream</B>
<BR></FONT></A></H4>
<P>InputStream is an abstract <A ID = "I13" NAME = "I13"  ></A><A ID = "I14" NAME = "I14"  ></A><A ID = "I15" NAME = "I15"  ></A>class that defines the fundamental ways in which a destination (consumer) reads a stream of bytes from some source. The identity of the source, and the manner of the creation and transport of the bytes, is irrelevant. When using an input stream, you are the destination of those bytes, and that's all you need to know.
<BR></P>
<H5><A ID = "I16" NAME = "I16"  >
<foNT SIZE=3><B>read()</B>
<BR></FONT></A></H5>
<P>The most <A ID = "I17" NAME = "I17"  ></A><A ID = "I18" NAME = "I18"  ></A>important method to the consumer of an input stream is the one that reads bytes from the source. This method, read(), comes in many flavors, and each is demonstrated in an example in today's lesson.
<BR></P>
<P>Each of these read() methods is defined to &quot;block&quot; (wait) until all the input requested becomes available. Don't worry about this limitation; because of multithreading, you can do as many other things as you like while this one thread is waiting for input. In fact, it is a common idiom to assign a thread to each stream of input (and for each stream of output) that is solely responsible for reading from it (or writing to it). These input threads might then &quot;hand off&quot; the information to other threads for processing. This naturally overlaps the I/O time of your program with its compute time.
<BR></P>
<P>Here's the first form of read():
<BR></P>
<PRE>InputStream  s      = getAnInputStreamFromSomewhere();
byte[]       buffer = new byte[1024];   // any size will do
if (s.read(buffer) != buffer.length)
    System.out.println(&quot;I got less than I expected.&quot;);</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Here, and throughout the rest of today's lesson, assume that either an import java.io.* appears before all the examples or that you mentally prefix all references to java.io classes with the prefix java.io.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>This form of read() attempts to fill <A ID = "I19" NAME = "I19"  ></A><A ID = "I20" NAME = "I20"  ></A>the entire buffer given. If it cannot (usually due to reaching the end of the input stream), it returns the actual number of bytes that were read into the buffer. After that, any further calls to read() return -1, indicating that you are at the end of the stream. Note that the if statement still works even in this case, because -1 != 1024 (this corresponds to an input stream with no bytes in it all).
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Don't forget that, unlike in C, the -1 case in Java is not used to indicate an error. <A ID = "I21" NAME = "I21"  ></A><A ID = "I22" NAME = "I22"  ></A>Any I/O errors throw instances of IOException (which you're not catching yet). You learned on Day 17 that all uses of distinguished values can be replaced by the use of exceptions, and so they should. The -1 in the last example is a bit of a historical anachronism. You'll soon see a better approach to indicating end of the stream using the class DataInputStream.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>You can also read into a &quot;slice&quot; of your buffer by specifying the offset into the buffer, and the length desired, as arguments to read():
<BR></P>
<PRE>s.read(buffer, 100, 300);</PRE>
<P>This example tries to fill in bytes 100 through 399 and behaves otherwise exactly the same as the previous read() method. In fact, in the current release, the default implementation of the former version of read() uses the latter:
<BR></P>
<PRE>public int  read(byte[]  buffer) throws IOException {
    return  read(buffer, 0, buffer.length);
}</PRE>
<P>Finally, you can read in bytes one at a time:
<BR></P>
<PRE>InputStream  s = getAnInputStreamFromSomewhere(); 
<BR>byte         b;
int          byteOrMinus1;
while ((byteOrMinus1 = s.read()) != -1) {
     b = (byte) byteOrMinus1;
     . . .    // process the byte b
}
. . .    // reached end of stream</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Because of the nature of integer promotion in Java in general, and because in this case the read() method returns an int, using <A ID = "I23" NAME = "I23"  ></A><A ID = "I24" NAME = "I24"  ></A>the byte type in your code may be a little frustrating. You'll find yourself constantly having explicitly to cast the result of arithmetic expressions, or of int return values, back to your size. Because read() really should be returning a byte in this case, I feel justified in declaring and using it as such (despite the pain)&#151;it makes the size of the data being read clearer. In cases where you feel the range of a variable is naturally limited to a byte (or a short) rather than an int, please take the time to declare it that way and pay the small price necessary to gain the added clarity. By the way, a lot of the Java class library code simply stores the result of read() in an int. This proves that even the Java team is human&#151;<I>everyone</I> makes style mistakes.
<BR></NOTE>
<HR ALIGN=CENTER>
<H5><A ID = "I25" NAME = "I25"  >
<foNT SIZE=3><B>skip()</B>
<BR></FONT></A></H5>
<P>What if you want to <A ID = "I26" NAME = "I26"  ></A><A ID = "I27" NAME = "I27"  ></A><A ID = "I28" NAME = "I28"  ></A><A ID = "I29" NAME = "I29"  ></A>skip over some of the bytes in a stream, or start reading a stream from other than its beginning? A method similar to read() does the trick:
<BR></P>
<PRE>if (s.skip(1024) != 1024)
    System.out.println(&quot;I skipped less than I expected.&quot;);</PRE>
<P>This skips over the next 1024 bytes in the input stream. skip() takes and returns a long integer, because streams are not required to be limited to any particular size. The default implementation of skip in this release simply uses read():
<BR></P>
<PRE>public long  skip(long n) throws IOException {
    byte[]  buffer = new byte[(int) n];
    return  read(buffer);
}</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>This implementation does not support large skips correctly, because its long argument is cast to an int. Subclasses must override this default implementation if they want to handle this more properly. This won't be as easy as you might think, because the current release of the Java system does not allow integer types larger than int to act as array subscripts.
<BR></NOTE>
<HR ALIGN=CENTER>
<H5><A ID = "I30" NAME = "I30"  >
<foNT SIZE=3><B>available()</B>
<BR></FONT></A></H5>
<P>If for some reason <A ID = "I31" NAME = "I31"  ></A><A ID = "I32" NAME = "I32"  ></A>you would like to know how many bytes are in the stream right now, you can ask:
<BR></P>
<PRE>if (s.available() &lt; 1024)
    System.out.println(&quot;Too little is available right now.&quot;);</PRE>
<P>This tells you the number of bytes that you can read() without blocking. Because of the abstract nature of the source of these bytes, streams may or may not be able to tell you a reasonable answer to this question. For example, some streams always return 0. Unless you use specific subclasses of InputStream that you know provide a reasonable answer to this question, it's not a good idea to rely upon this method. Remember, multithreading eliminates many of the problems associated with blocking while waiting for a stream to fill again. Thus, one of the strongest rationales for the use of available() goes away.
<BR></P>
<H5><A ID = "I33" NAME = "I33"  >
<foNT SIZE=3><B>mark() and reset()</B>
<BR></FONT></A></H5>
<P>Some streams <A ID = "I34" NAME = "I34"  ></A><A ID = "I35" NAME = "I35"  ></A><A ID = "I36" NAME = "I36"  ></A><A ID = "I37" NAME = "I37"  ></A>support the notion of marking a position in <A ID = "I38" NAME = "I38"  ></A><A ID = "I39" NAME = "I39"  ></A><A ID = "I40" NAME = "I40"  ></A>the stream, and then later resetting the stream to that position to reread the bytes there. Clearly, the stream would have to &quot;remember&quot; all those bytes, so there is a limitation on how far apart in a stream the mark and its subsequent reset can occur. There's also a method that asks whether or not the stream supports the notion of marking at all. Here's an example:
<BR></P>
<PRE>InputStream  s = getAnInputStreamFromSomewhere();
if (s.markSupported()) {    // does s support the notion?
    . . .        // read the stream for a while
    s.mark(1024);
    . . .        // read less than 1024 more bytes
    s.reset();
    . . .        // we can now re-read those bytes
} else {
    . . .                   // no, perform some alternative
}</PRE>
<P>When marking a stream, you specify the maximum number of bytes you intend to allow to pass before resetting it. This allows the stream to limit the size <A ID = "I41" NAME = "I41"  ></A><A ID = "I42" NAME = "I42"  ></A><A ID = "I43" NAME = "I43"  ></A>of its byte &quot;memory.&quot; If this number of bytes goes by and you have not yet reset(), the mark becomes invalid, and attempting to reset() will throw an exception.
<BR></P>
<P>Marking and resetting a stream is most valuable when you are attempting to identify the type of the stream (or the next part of the stream), but to do so, you must consume a significant piece of it in the process. Often, this is because you have several black-box parsers that you can hand the stream to, but they will consume some (unknown to you) number of bytes before making up their mind about whether the stream is of their type. Set a large size for the read limit above, and let each parser run until it either throws an error or completes a successful parse. If an error is thrown, reset() and try the next parser.
<BR></P>
<H5><A ID = "I44" NAME = "I44"  >
<foNT SIZE=3><B>close()</B>
<BR></FONT></A></H5>
<P>Because you don't <A ID = "I45" NAME = "I45"  ></A><A ID = "I46" NAME = "I46"  ></A>know what resources an open stream represents, nor how to deal with them properly when you're finished reading the stream, you should (usually) explicitly close down a stream so that it can release these resources. Of course, garbage collection and a finalization method can do this for you, but what if you need to reopen that stream or those resources before they have been freed by this asynchronous process? At best, this is annoying or confusing; at worst, it introduces an unexpected, obscure, and difficult-to-track-down bug. Because you're interacting with the outside world of external resources, it's safer to be explicit about when you're finished using them:
<BR></P>
<PRE>InputStream  s = alwaysMakesANewInputStream();
try {
    . . .     // use s to your heart's content
} finally {
    s.close();
}</PRE>
<P>Get used to this idiom (using finally); it's a useful way to be sure something (such as closing the stream) always gets done. Of course, you're assuming that the stream is always successfully created. If this is not always the case, and null is sometimes returned instead, here's the correct way to be safe:
<BR></P>
<PRE>InputStream  s = tryToMakeANewInputStream();
if (s != null) {
    try {
        . . .
    } finally {
        s.close();
    }
}</PRE>
<P>All input streams descend from the abstract class InputStream. All share in common the few methods described so far. Thus, stream s in the previous examples could have been any of the more complex input streams described in the next few sections.
<BR></P>
<H4><A ID = "I47" NAME = "I47"  >
<foNT SIZE=3><B>ByteArrayInputStream</B>
<BR></FONT></A></H4>
<P>The &quot;inverse&quot; of some <A ID = "I48" NAME = "I48"  ></A><A ID = "I49" NAME = "I49"  ></A>of the previous examples would be to create an input stream <I>from</I> an <A ID = "I50" NAME = "I50"  ></A><A ID = "I51" NAME = "I51"  ></A><A ID = "I52" NAME = "I52"  ></A><A ID = "I53" NAME = "I53"  ></A><A ID = "I54" NAME = "I54"  ></A>array of bytes. This is exactly what ByteArrayInputStream does:
<BR></P>
<PRE>byte[]  buffer = new byte[1024];
fillWithUsefulData(buffer);
InputStream  s = new ByteArrayInputStream(buffer);</PRE>
<P>Readers of the new stream s see a stream 1024 bytes long, containing the bytes in the array buffer. Just as read() has a form that takes an offset and a length, so does this class's constructor:
<BR></P>
<PRE>InputStream  s = new ByteArrayInputStream(buffer, 100, 300);</PRE>
<P>Here, the stream is 300 bytes long and consists of bytes 100-399 from the array buffer.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Finally, you've seen your first examples of the <I>creation</I> of a stream. These new streams are attached to the simplest of all possible sources of data, an array of bytes in the memory of the local computer.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>ByteArrayInputStreams simply implement the standard set of methods that all input streams do. Here, however, the available() method has a particularly simple job&#151;it returns 1024 and 300, respectively, for the two instances of ByteArrayInputStream you created previously, because it knows exactly how many bytes are available. Finally, calling reset() on a ByteArrayInputStream resets it to the beginning of the stream (buffer), no matter where the mark is set.
<BR></P>
<H4><A ID = "I55" NAME = "I55"  >
<foNT SIZE=3><B>FileInputStream</B>
<BR></FONT></A></H4>
<P>One of the most <A ID = "I56" NAME = "I56"  ></A><A ID = "I57" NAME = "I57"  ></A>common uses of streams, and historically the earliest, is to attach <A ID = "I58" NAME = "I58"  ></A><A ID = "I59" NAME = "I59"  ></A><A ID = "I60" NAME = "I60"  ></A>them to files in the file system. Here, for example, is the creation of such an input stream on a UNIX system:
<BR></P>
<PRE>InputStream  s = new FileInputStream(&quot;/some/path/and/fileName&quot;);</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="caution.gif" tppabs="http://newdata.box.sk/bx/java/caution.gif" WIDTH = 37 HEIGHT = 35><B>Caution: </B>Applets attempting to open, read, or write streams based on files in the file system can cause security violations (depending on the paranoia level set by the user of the browser). Try to create applets that do not depend on files at all, by using servers to hold shared information. If that's impossible, limit your applet's I/O to a single file or directory to which the user can easily assign file access permission. (Stand-alone Java programs have none of these problems, of course.)
<BR></NOTE>
<HR ALIGN=CENTER>
<P>You also can create the <A ID = "I61" NAME = "I61"  ></A><A ID = "I62" NAME = "I62"  ></A><A ID = "I63" NAME = "I63"  ></A>stream from a previously opened file descriptor:
<BR></P>
<PRE>int          fd = openInputFileInTraditionalUNIXWays();
InputStream  s  = new FileInputStream(fd);</PRE>
<P>In either case, because it's based on an actual (finite length) file, the input stream created can implement available() precisely and can skip() like a champ (just as ByteArrayInputStream can, by the way). In addition, FileInputStream knows a few more tricks:
<BR></P>
<PRE>FileInputStream  aFIS = new FileInputStream(&quot;aFileName&quot;);
int  myFD = aFIS.getFD();
/* aFIS.finalize(); */  // will call close() when automatically called by GC</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="imp.gif" tppabs="http://newdata.box.sk/bx/java/imp.gif" WIDTH = 68 HEIGHT = 35><B>Tip: </B>To call the <A ID = "I64" NAME = "I64"  ></A><A ID = "I65" NAME = "I65"  ></A>new methods, you must declare the stream variable aFIS to be of type FileInputStream, because plain InputStreams don't know about them.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>The first is obvious: getFD() returns the file descriptor of the file on which the stream is based. The second, though, is an interesting shortcut that allows you to create FileInputStreams without worrying about closing them later. FileInputStream's implementation of finalize(), a protected method, closes <A ID = "I66" NAME = "I66"  ></A><A ID = "I67" NAME = "I67"  ></A>the stream. Unlike in the contrived call in comments, you almost never can nor should call a finalize() method directly. The garbage collector calls it after noticing that the stream is no longer in use, but before actually destroying the stream. Thus, you can go merrily along using the stream, never closing it, and all will be well. The system takes care of closing it (eventually).
<BR></P>
<P>You can get away with this because streams based on files tie up very few resources, and these resources cannot be accidentally reused before garbage collection (these were the things worried about in the previous discussion of finalization and close()). Of course, if you were also <I>writing</I> to the file, you would have to be more careful. (Reopening the file too soon after writing might make it appear in an inconsistent state because the finalize()&#151;and thus the close()&#151;might not have happened yet). Just because you don't <I>have</I> to close the stream doesn't mean you might not want to do so anyway. For clarity, or if you don't know precisely what type of an InputStream you were handed, you might choose to call close() yourself.
<BR></P>
<H4><A ID = "I68" NAME = "I68"  >
<foNT SIZE=3><B>FilterInputStream</B>
<BR></FONT></A></H4>
<P>This &quot;abstract&quot; class <A ID = "I69" NAME = "I69"  ></A><A ID = "I70" NAME = "I70"  ></A><A ID = "I71" NAME = "I71"  ></A>simply provides a &quot;pass-through&quot; for all the standard methods of InputStream. It holds inside itself another stream, by definition one further &quot;down&quot; the chain of filters, to which it forwards all method calls. It implements nothing new but allows itself to be nested:
<BR></P>
<PRE>InputStream        s  = getAnInputStreamFromSomewhere();
FilterInputStream  s1 = new FilterInputStream(s);
FilterInputStream  s2 = new FilterInputStream(s1);
FilterInputStream  s3 = new FilterInputStream(s2);
... s3.read() ...</PRE>
<P>Whenever a read is performed on the filtered stream s3, it passes along the request to s2; then s2 does the same to s1, and finally s is asked to provide the bytes. Subclasses of FilterInputStream will, of course, do some nontrivial processing of the bytes as they flow past. The rather verbose form of &quot;chaining&quot; in the previous example can be made more elegant:
<BR></P>
<PRE>s3 = new FilterInputStream(new FilterInputStream(new FilterInputStream(s)));</PRE>
<P>You should use this idiom in your code whenever you can. It clearly expresses the nesting <A ID = "I72" NAME = "I72"  ></A><A ID = "I73" NAME = "I73"  ></A><A ID = "I74" NAME = "I74"  ></A>of chained filters, and can easily be parsed and &quot;read aloud&quot; by starting at the innermost stream s and reading outward&#151;each filter stream applying to the one within&#151;until you reach the outermost stream s3.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>FilterInputStream is called &quot;abstract,&quot; rather than abstract, because it is not actually declared to be abstract. This means that, as useless as they are, you can create instances of FilterInputStream directly. The same will hold for its output stream &quot;brother&quot; class, described later today.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>Now let's examine each of the subclasses of FilterInputStream in turn.
<BR></P>
<H5><A ID = "I75" NAME = "I75"  >
<foNT SIZE=3><B>BufferedInputStream</B>
<BR></FONT></A></H5>
<P>This is one of the most <A ID = "I76" NAME = "I76"  ></A><A ID = "I77" NAME = "I77"  ></A>valuable of all streams. It implements the full complement of InputStream's methods, but it does so by using a buffered array of bytes that acts as a cache for future reading. This decouples the rate and the size of the &quot;chunks&quot; you're reading from the more regular, larger block sizes in which streams are most efficiently read (from, for example, peripheral devices, files in the file system, or the network). It also allows smart streams to read ahead when they expect that you will want more data soon.
<BR></P>
<P>Because the buffering of BufferedInputStream is so valuable, and it's also the only class to handle mark() and reset() properly, you might wish that every input stream could somehow share its valuable capabilities. Normally, because those stream classes do not implement them, you would be out of luck. Fortunately, you already saw a way that filter streams can wrap themselves &quot;around&quot; other streams. Suppose that you would like a buffered FileInputStream that can handle marking and resetting correctly. Et voil&#224;:
<BR></P>
<PRE>InputStream  s = new BufferedInputStream(new FileInputStream(&quot;foo&quot;));</PRE>
<P>You have a buffered input stream based on the file &quot;foo&quot; that can mark() and reset().
<BR></P>
<P>Now you can begin to see the power of nesting streams. Any capability provided by a filter input stream (or output stream, as you'll see soon) can be used by any other, basic stream via nesting. Of course, any <I>combination</I> of these capabilities, and in any order, can be as easily accomplished by nesting the filter streams themselves.
<BR></P>
<H5><A ID = "I78" NAME = "I78"  >
<foNT SIZE=3><B>DataInputStream</B>
<BR></FONT></A></H5>
<P>All the methods <A ID = "I79" NAME = "I79"  ></A><A ID = "I80" NAME = "I80"  ></A>that instances of this class understand are defined in a separate interface, which both DataInputStream and RandomAccessFile (another class in java.io) implement. This interface is general-purpose enough that you might want to use it yourself in the classes you create. It is called DataInput.
<BR></P>
<H6>
<foNT SIZE=3><B>The </B><B>DataInput</B><B> Interface</B>
<BR></FONT></H6>
<P>When you begin using <A ID = "I81" NAME = "I81"  ></A><A ID = "I82" NAME = "I82"  ></A>streams to any degree, you'll quickly discover that byte streams are not a really helpful format into which to force all data. In particular, the primitive types of the Java language embody a rather nice way of looking at data, but with the streams you've been defining thus far in this book, you could not read data of these types. The DataInput interface specifies a higher-level set of methods that, when used for both reading and writing, can support a more complex, typed stream of data. Here are the set of methods this interface defines:
<BR></P>
<PRE>void  readFully(byte[]  buffer)                           throws IOException;
void  readFully(byte[]  buffer, int  offset, int  length) throws IOException;
int   skipBytes(int n)                                    throws IOException;
boolean  readBoolean()       throws IOException;
byte     readByte()          throws IOException;
int      readUnsignedByte()  throws IOException;
short    readShort()         throws IOException;
int      readUnsignedShort() throws IOException;
char     readChar()          throws IOException;
int      readInt()           throws IOException;
long     readLong()          throws IOException;
float    readFloat()         throws IOException;
double   readDouble()        throws IOException;
String   readLine()          throws IOException;
String   readUTF()           throws IOException;</PRE>
<P>The first three methods are simply new names for skip() and the two forms of read() you've seen previously. Each of the next ten methods reads in a primitive type, or its unsigned counterpart (useful for using every bit efficiently in a binary stream). These latter methods must return an integer of a wider size than you might think; because integers are signed in Java, the unsigned value does not fit in anything smaller. The final two methods <A ID = "I83" NAME = "I83"  ></A>read a newline ('\r', '\n', or &quot;\r\n&quot;) terminated string of characters from the stream&#151;the first in ASCII, and the second in Unicode.
<BR></P>
<P>Now that you know what the interface that DataInputStream implements looks like, let's see it in action:
<BR></P>
<PRE>DataInputStream  s = new DataInputStream(getNumericInputStream());
long  size = s.readLong();    // the number of items in the stream
while (size&#151; &gt; 0) {
    if (s.readBoolean()) {    // should I process this item?
        int     anInteger     = s.readInt();
        int     magicBitFlags = s.readUnsignedShort();
        double  aDouble       = s.readDouble();
        if ((magicBitFlags &amp; 0100000) != 0) {
            . . .    // high bit set, do something special
        }
        . . .    // process anInteger and aDouble
    }
}</PRE>
<P>Because the class implements an interface for all its methods, you can also use the following interface:
<BR></P>
<PRE>DataInput  d = new DataInputStream(new FileInputStream(&quot;anything&quot;));
String     line;
while ((line = d.readLine()) != null) {
    . . .     // process the line
}</PRE>
<H6>
<foNT SIZE=3><B>The EOFException</B>
<BR></FONT></H6>
<P>One final point <A ID = "I84" NAME = "I84"  ></A><A ID = "I85" NAME = "I85"  ></A>about most of DataInputStream's methods: when the end of the stream is reached, they throw an EOFException. This is tremendously useful and, in fact, allows you to rewrite all the kludgy uses of -1 you saw earlier today in a much nicer fashion:
<BR></P>
<PRE>DataInputStream  s = new DataInputStream(getAnInputStreamFromSomewhere());
try {
    while (true) {
        byte  b = (byte) s.readByte();
        . . .    // process the byte b
    }
} catch (EOFException e) {
    . . .    // reached end of stream
}</PRE>
<P>This works just as well for all but the last two of the read methods of DataInputStream.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="caution.gif" tppabs="http://newdata.box.sk/bx/java/caution.gif" WIDTH = 37 HEIGHT = 35><B>Caution:</B> skipBytes() does nothing at all on end of stream, readLine() returns null, and readUTF() might throw a UTFDataFormatException, if it notices the problem at all.
<BR></NOTE>
<HR ALIGN=CENTER>
<H5><A ID = "I86" NAME = "I86"  >
<foNT SIZE=3><B>LineNumberInputStream</B>
<BR></FONT></A></H5>
<P>In an editor or a <A ID = "I87" NAME = "I87"  ></A><A ID = "I88" NAME = "I88"  ></A>debugger, line numbering is crucial. To add this valuable capability to your programs, use the filter <A ID = "I89" NAME = "I89"  ></A><A ID = "I90" NAME = "I90"  ></A>stream LineNumberInputStream, which keeps track of line numbers as its stream &quot;flows through&quot; it. It's even smart enough to remember a line number and later restore it, during a mark() and reset(). You might use this class as follows:
<BR></P>
<PRE>LineNumberInputStream  aLNIS;
aLNIS = new LineNumberInputStream(new FileInputStream(&quot;source&quot;));
DataInputStream  s = new DataInputStream(aLNIS);
String           line;
while ((line = s.readLine()) != null) {
    . . .    // process the line
    System.out.println(&quot;Did line number: &quot; + aLNIS.getLineNumber());
}</PRE>
<P>Here, two filter streams are nested around the FileInputStream actually providing the data&#151;the first to read lines one at a time and the second to keep track of the line numbers of these lines as they go by. You must explicitly name the intermediate filter stream, aLNIS, because if you did not, you couldn't call getLineNumber() later. Note that if you invert the order of the nested streams, reading from the DataInputStream does not cause the LineNumberInputStream to &quot;see&quot; the lines.
<BR></P>
<P>You must put any filter streams acting as &quot;monitors&quot; in the middle of the chain and &quot;pull&quot; the data from the outermost filter stream so that the data will pass through each of the monitors in turn. In the same way, buffering should occur as far inside the chain as possible, because it won't be able to do its job properly unless most of the streams that need buffering come after it in the flow. For example, here's a silly order:
<BR></P>
<PRE>new BufferedInputStream(new LineNumberInputStream(
            _new DataInputStream(new FileInputStream(&quot;foo&quot;));</PRE>
<P>and here's a much better order:
<BR></P>
<PRE>new DataInputStream(new LineNumberInputStream(
            _new BufferedInputStream(new FileInputStream(&quot;foo&quot;));</PRE>
<P>LineNumberInputStreams can also be told to setLineNumber(), for those few times when you know more than they do.
<BR></P>
<H5><A ID = "I91" NAME = "I91"  >
<foNT SIZE=3><B>PushbackInputStream</B>
<BR></FONT></A></H5>
<P>The filter stream class PushbackInputStream<A ID = "I92" NAME = "I92"  ></A><A ID = "I93" NAME = "I93"  ></A> is commonly used in parsers, to &quot;push back&quot; a single character in the input (after reading it) while trying to determine what to do next&#151;a simplified version of the mark() and reset() utility you learned about earlier. Its only addition to the standard set of InputStream methods is unread(), which as you might guess, pretends that it never read the byte passed in as its argument, and then gives that byte back as the return value of the next read().
<BR></P>
<P>The following is a simple implementation of readLine()<A ID = "I94" NAME = "I94"  ></A><A ID = "I95" NAME = "I95"  ></A> using this class:
<BR></P>
<PRE>public class  SimpleLineReader {
    private FilterInputStream  s;
    public  SimpleLineReader(InputStream  anIS) {
        s = new DataInputStream(anIS);
    }
    . . .    // other read() methods using stream s
    public String  readLine() throws IOException {
        char[]  buffer = new char[100];
        int     offset = 0;
        byte    thisByte;
        try {
loop:        while (offset &lt; buffer.length) {
                switch (thisByte = (byte) s.read()) {
                    case '\n':
                        break loop;
                    case '\r':
                        byte  nextByte = (byte) s.read();
                        if (nextByte != '\n') {
                            if (!(s instanceof PushbackInputStream)) {
                                s = new PushbackInputStream(s);
                            }
                            ((PushbackInputStream) s).unread(nextByte);
                        }
                        break loop;
                    default:
                        buffer[offset++] = (char) thisByte;
                        break;
                }
            }
        } catch (EOFException e) {
            if (offset == 0)
                return null;
        }
        return String.copyValueOf(buffer, 0, offset);
    }
}</PRE>
<P>This demonstrates numerous things. For the purpose of this example, readLine() is restricted to reading the first 100 characters of the line. In this respect, it demonstrates how <I>not</I> to write a general-purpose line processor (you should be able to read any size line). It also reminds you how to break out of an outer loop, and how to produce a String from an array of characters (in this case, from a &quot;slice&quot; of the array of characters). This example also includes standard uses of InputStream's read() for reading bytes one at a time, and of determining the end of the stream by enclosing it in a DataInputStream and catching EOFException.
<BR></P>
<P>One of the more unusual aspects of the example is the way PushbackInputStream is used. To be sure that '\n' is ignored following '\r' you have to &quot;look ahead&quot; one character; but if it is not a '\n', you must push back that character. Look at the next two lines as if you didn't know much about the stream s. The general technique used is instructive. First, you see whether s is already an instanceof some kind of PushbackInputStream. If so, you can simply use it. If not, you enclose the current stream (whatever it is) inside a new PushbackInputStream and use this new stream. Now, let's jump back into the context of the example.
<BR></P>
<P>The line following wants to call the method unread(). The problem is that s has a &quot;compile-time type&quot; of FilterInputStream, and thus doesn't understand that method. The previous two lines have guaranteed, however, that the <I>run-time type</I> of the stream in s is PushbackInputStream, so you can safely cast it to that type and then safely call unread().
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note:</B> This example was done in an unusual way for demonstration purposes. You could have simply declared a PushbackInputStream variable and always enclosed the DataInputStream in it. (Conversely, SimpleLineReader's constructor could have checked whether its argument was already of the right class, the way PushbackInputStream did, before creating a new DataInputStream.) The interesting thing about this approach of &quot;wrapping a class only when needed&quot; is that it works for any InputStream that you hand it, and it does additional work only if it needs to. Both of these are good general design principles.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>All the subclasses of FilterInputStream have now been described. It's time to return to the direct subclasses of InputStream.
<BR></P>
<H4><A ID = "I96" NAME = "I96"  >
<foNT SIZE=3><B>PipedInputStream</B>
<BR></FONT></A></H4>
<P>This class, along <A ID = "I97" NAME = "I97"  ></A><A ID = "I98" NAME = "I98"  ></A>with its &quot;brother&quot; class PipedOutputStream, are covered later today (they need to be understood and demonstrated together). For now, all you need to know is that together they create a simple, two-way communication conduit between threads.
<BR></P>
<H4><A ID = "I99" NAME = "I99"  >
<foNT SIZE=3><B>SequenceInputStream</B>
<BR></FONT></A></H4>
<P>Suppose you have two <A ID = "I100" NAME = "I100"  ></A><A ID = "I101" NAME = "I101"  ></A>separate streams, and you would like to make a composite stream that consists of one stream followed by the other (like appending two Strings together). This is exactly what SequenceInputStream was created for:
<BR></P>
<PRE>InputStream  s1 = new FileInputStream(&quot;theFirstPart&quot;);
InputStream  s2 = new FileInputStream(&quot;theRest&quot;);
InputStream  s  = new SequenceInputStream(s1, s2);
... s.read() ...   // reads from each stream in turn</PRE>
<P>You could have &quot;faked&quot; this example by reading each file in turn&#151;but what if you had to hand the composite stream s to some other method that was expecting only a single InputStream? Here's an example (using s) that line-numbers the two previous files with a common numbering scheme:
<BR></P>
<PRE>LineNumberInputStream  aLNIS = new LineNumberInputStream(s);
... aLNIS.getLineNumber() ...</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Stringing together <A ID = "I102" NAME = "I102"  ></A><A ID = "I103" NAME = "I103"  ></A>streams this way is especially useful when the streams are of unknown length and origin, and were just handed to you by someone else.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>What if you want to string together more than two streams? You could try the following:
<BR></P>
<PRE>Vector  v = new Vector();
. . .   // set up all the streams and add each to the Vector
InputStream  s1 = new SequenceInputStream(v.elementAt(0), v.elementAt(1));
InputStream  s2 = new SequenceInputStream(s1, v.elementAt(2));
InputStream  s3 = new SequenceInputStream(s2, v.elementAt(3));
. . .</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note:</B> A Vector is a <A ID = "I104" NAME = "I104"  ></A><A ID = "I105" NAME = "I105"  ></A>growable array of objects that can be filled, referenced (with elementAt()) and enumerated. 
<BR></NOTE>
<HR ALIGN=CENTER>
<P>However, it's much easier to use a different constructor that SequenceInputStream provides:
<BR></P>
<PRE>InputStream  s  = new SequenceInputStream(v.elements());</PRE>
<P>It takes an enumeration of all the streams you wish to combine and returns a single stream that reads through the data of each in turn.
<BR></P>
<H4><A ID = "I106" NAME = "I106"  >
<foNT SIZE=3><B>StringBufferInputStream</B>
<BR></FONT></A></H4>
<P>StringBufferInputStream <A ID = "I107" NAME = "I107"  ></A><A ID = "I108" NAME = "I108"  ></A>is exactly like ByteArrayInputStream, but instead of being based on a byte array, it's based on an array of characters (a String):
<BR></P>
<PRE>String       buffer = &quot;Now is the time for all good men to come...&quot;;
InputStream  s      = new StringBufferInputStream(buffer);</PRE>
<P>All comments that were made about ByteArrayInputStream apply here as well. (See the earlier section on that class.)
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>StringBufferInputStream is a bit of a misnomer, because this input stream is actually based on a String. It should really be called StringInputStream.
<BR></NOTE>
<HR ALIGN=CENTER>
<H3><A ID = "I109" NAME = "I109"  >
<foNT SIZE=4><B>Output Streams</B>
<BR></FONT></A></H3>
<P>Output streams are, in <A ID = "I110" NAME = "I110"  ></A><A ID = "I111" NAME = "I111"  ></A>almost every case, paired with a &quot;brother&quot; InputStream that you've already learned. If an InputStream performs a certain operation, the &quot;brother&quot; OutputStream performs the <I>inverse</I> operation. You'll see more of what this means soon.
<BR></P>
<H4><A ID = "I112" NAME = "I112"  >
<foNT SIZE=3><B>The abstract Class OutputStream</B>
<BR></FONT></A></H4>
<P>OutputStream is the abstract <A ID = "I113" NAME = "I113"  ></A><A ID = "I114" NAME = "I114"  ></A><A ID = "I115" NAME = "I115"  ></A>class that defines the fundamental ways in which a source (producer) writes a stream of bytes to some destination. The identity of the destination, and the manner of the transport and storage of the bytes, is irrelevant. When using an output stream, <I>you </I>are the source of those bytes, and that's all you need to know.
<BR></P>
<H5><A ID = "I116" NAME = "I116"  >
<foNT SIZE=3><B>write()</B>
<BR></FONT></A></H5>
<P>The most important <A ID = "I117" NAME = "I117"  ></A><A ID = "I118" NAME = "I118"  ></A>method to the producer of an output stream is the one that writes bytes to the <A ID = "I119" NAME = "I119"  ></A><A ID = "I120" NAME = "I120"  ></A>destination. This method, write(), comes in many flavors, each demonstrated in an example below.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>Every one of these write() methods is defined to &quot;block&quot; (wait) until all the output requested has been written. You don't need to worry about this limitation&#151;see the note under InputStream's read() method if you don't remember why.
<BR></NOTE>
<HR ALIGN=CENTER>
<PRE>OutputStream  s      = getAnOutputStreamFromSomewhere();
byte[]        buffer = new byte[1024];    // any size will do
fillInData(buffer);    // the data we want to output
s.write(buffer);</PRE>
<P>You also can write a &quot;slice&quot; of your buffer by specifying the offset into the buffer, and the length desired, as arguments to write():
<BR></P>
<PRE>s.write(buffer, 100, 300);</PRE>
<P>This writes out bytes 100 through 399 and behaves otherwise exactly the same as the previous write() method. In fact, in the current release, the default implementation of the former version of write() uses the latter:
<BR></P>
<PRE>public void  write(byte[]  buffer) throws IOException {
    write(buffer, 0, buffer.length);
}</PRE>
<P>Finally, you can write out bytes one at a time:
<BR></P>
<PRE>while (thereAreMoreBytesToOutput()) {
    byte  b = getNextByteForOutput();
    s.write(b);
}</PRE>
<H5><A ID = "I121" NAME = "I121"  >
<foNT SIZE=3><B>flush()</B>
<BR></FONT></A></H5>
<P>Because you don't <A ID = "I122" NAME = "I122"  ></A><A ID = "I123" NAME = "I123"  ></A>know what an output stream is connected to, you might be required to &quot;flush&quot; your output <A ID = "I124" NAME = "I124"  ></A><A ID = "I125" NAME = "I125"  ></A><A ID = "I126" NAME = "I126"  ></A>through some buffered cache to get it to be written (in a timely manner, or at all). OutputStream's version of this method does nothing, but it is expected that subclasses that require flushing (for example, BufferedOutputStream and PrintStream) will override this version to do something nontrivial.
<BR></P>
<H5><A ID = "I127" NAME = "I127"  >
<foNT SIZE=3><B>close()</B>
<BR></FONT></A></H5>
<P>Just like for an<A ID = "I128" NAME = "I128"  ></A><A ID = "I129" NAME = "I129"  ></A> InputStream, you should (usually) explicitly close down an OutputStream so that it can release <A ID = "I130" NAME = "I130"  ></A><A ID = "I131" NAME = "I131"  ></A><A ID = "I132" NAME = "I132"  ></A>any resources it may have reserved on your behalf. (All the same notes and examples from InputStream's close() method apply here, with the prefix In replaced everywhere by Out.)
<BR></P>
<P>All output streams descend from the abstract class OutputStream. All share the previous few methods in common.
<BR></P>
<H4><A ID = "I133" NAME = "I133"  >
<foNT SIZE=3><B>ByteArrayOutputStream</B>
<BR></FONT></A></H4>
<P>The inverse of ByteArrayInputStream<A ID = "I134" NAME = "I134"  ></A><A ID = "I135" NAME = "I135"  ></A>, which creates an input stream from an array of bytes, is ByteArrayOutputStream, which <A ID = "I136" NAME = "I136"  ></A><A ID = "I137" NAME = "I137"  ></A><A ID = "I138" NAME = "I138"  ></A><A ID = "I139" NAME = "I139"  ></A>directs an output stream <I>into</I> an array of bytes:
<BR></P>
<PRE>OutputStream  s = new ByteArrayOutputStream();
s.write(123);
. . .</PRE>
<P>The size of the (internal) byte <A ID = "I140" NAME = "I140"  ></A><A ID = "I141" NAME = "I141"  ></A>array grows as needed to store a stream of any length. You can provide an initial capacity as an aid to the class, if you like:
<BR></P>
<PRE>OutputStream  s = new ByteArrayOutputStream(1024 * 1024);  // 1 Megabyte</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note:</B> You've just seen your first examples of the creation of an output stream. These new streams were attached to the simplest of all possible destinations of data, an array of bytes in the memory of the local computer.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>Once the ByteArrayOutputStream s has been &quot;filled,&quot; it can be output to another output stream:
<BR></P>
<PRE>OutputStream           anotherOutputStream = getTheOtherOutputStream(); 
ByteArrayOutputStream  s = new ByteArrayOutputStream();
fillWithUsefulData(s);
s.writeTo(anotherOutputStream);</PRE>
<P>It also can be extracted as a byte array or converted to a String:
<BR></P>
<PRE>byte[]  buffer              = s.toByteArray();
String  bufferString        = s.toString();
String  bufferUnicodeString = s.toString(upperByteValue);</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>The last method allows you to &quot;fake&quot; Unicode (16-bit) characters by filling in their lower bytes with ASCII and then specifying a common upper byte (usually 0) to create a Unicode String result.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>ByteArrayOutputStreams have two utility methods: one simply returns the current number of bytes stored in the internal byte array, and the other resets the array so that the stream can be rewritten from the beginning:
<BR></P>
<PRE>int  sizeOfMyByteArray = s.size();
s.reset();     // s.size() would now return 0
s.write(123);
. . .</PRE>
<H4><A ID = "I142" NAME = "I142"  >
<foNT SIZE=3><B>FileOutputStream</B>
<BR></FONT></A></H4>
<P>One of the most common <A ID = "I143" NAME = "I143"  ></A><A ID = "I144" NAME = "I144"  ></A><A ID = "I145" NAME = "I145"  ></A><A ID = "I146" NAME = "I146"  ></A>uses of streams is to attach them to files in the file system. Here, for example, is the creation of such an output stream on a UNIX system:
<BR></P>
<PRE>OutputStream  s = new FileOutputStream(&quot;/some/path/and/fileName&quot;);</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="caution.gif" tppabs="http://newdata.box.sk/bx/java/caution.gif" WIDTH = 37 HEIGHT = 35><B>Caution: </B>Applets attempting to open, read, or write streams based on files in the file system can cause security violations. See the note under FileInputStream for more details.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>You also can create the stream from a previously opened file descriptor:
<BR></P>
<PRE>int           fd = openOutputFileInTraditionalUNIXWays();
OutputStream  s  = new FileOutputStream(fd);</PRE>
<P>FileOutputStream is the inverse of FileInputStream, and it knows the same tricks:
<BR></P>
<PRE>FileOutputStream  aFOS = new FileOutputStream(&quot;aFileName&quot;);
int  myFD = aFOS.getFD();
/* aFOS.finalize(); */  // will call close() when automatically called by GC</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>To call the new methods, you must declare the stream variable aFOS to be of type FileOutputStream, because plain OutputStreams don't know about them.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>The first is obvious: getFD() simply returns the file descriptor for the file on which the stream is based. The second, commented, contrived call to finalize() is there to remind you that you may not have to worry about closing this type of stream&#151;it is done for you automatically. (See the discussion under FileInputStream for more.)
<BR></P>
<H4><A ID = "I147" NAME = "I147"  >
<foNT SIZE=3><B>FilterOutputStream</B>
<BR></FONT></A></H4>
<P>This &quot;abstract&quot; class <A ID = "I148" NAME = "I148"  ></A><A ID = "I149" NAME = "I149"  ></A><A ID = "I150" NAME = "I150"  ></A>simply provides a &quot;pass-through&quot; for all the standard methods of OutputStream. It holds inside itself another stream, by definition one further &quot;down&quot; the chain of filters, to which it forwards all method calls. It implements nothing new but allows itself to be nested:
<BR></P>
<PRE>OutputStream        s  = getAnOutputStreamFromSomewhere();
FilterOutputStream  s1 = new FilterOutputStream(s);
FilterOutputStream  s2 = new FilterOutputStream(s1);
FilterOutputStream  s3 = new FilterOutputStream(s2);
... s3.write(123) ...</PRE>
<P>Whenever a write is performed on the filtered stream s3, it passes along the request to s2. Then s2 does the same to s1, and finally s is asked to output the bytes. Subclasses of FilterOutputStream, of course, do some nontrivial processing of the bytes as they flow past. This chain can be tightly nested&#151;see its &quot;brother&quot; class, FilterInputStream for more.
<BR></P>
<P>Now let's examine each of the subclasses of FilterOutputStream in turn.
<BR></P>
<H5><A ID = "I151" NAME = "I151"  >
<foNT SIZE=3><B>BufferedOutputStream</B>
<BR></FONT></A></H5>
<P>BufferedOutputStream is <A ID = "I152" NAME = "I152"  ></A><A ID = "I153" NAME = "I153"  ></A>one of the most valuable of all streams. All it does is implement the full complement of OutputStream's methods, but it does so by using a buffered array of bytes that acts as a cache for writing. This decouples the rate and the size of the &quot;chunks&quot; you're writing from the more regular, larger block sizes in which streams are most efficiently written (to peripheral devices, files in the file system, or the network, for example).
<BR></P>
<P>BufferedOutputStream is one of two classes in the Java library to implement flush(), which pushes the bytes you've written through the buffer and out the other side. Because buffering is so valuable, you might wish that every output stream could somehow be buffered. Fortunately, you can surround any output stream in such a way as to achieve just that:
<BR></P>
<PRE>OutputStream  s = new BufferedOutputStream(new FileOutputStream(&quot;foo&quot;));</PRE>
<P>You now have a buffered output stream based on the file &quot;foo&quot; that can be flush()ed.
<BR></P>
<P>Just as for filter input streams, any capability provided by a filter output stream can be used by any other basic stream via nesting and any combination of these capabilities, in any order, can be as easily accomplished by nesting the filter streams themselves.
<BR></P>
<H5><A ID = "I154" NAME = "I154"  >
<foNT SIZE=3><B>DataOutputStream</B>
<BR></FONT></A></H5>
<P>All the methods that <A ID = "I155" NAME = "I155"  ></A><A ID = "I156" NAME = "I156"  ></A>instances of this class understand are defined in a separate interface, which both DataOutputStream and RandomAccessFile implement. This interface is general-purpose enough that you might want use it yourself in the classes you create. It is called DataOutput.
<BR></P>
<H6>
<foNT SIZE=3><B>The </B><B>DataOutput</B><B> Interface</B>
<BR></FONT></H6>
<P>In cooperation with <A ID = "I157" NAME = "I157"  ></A><A ID = "I158" NAME = "I158"  ></A>its &quot;brother&quot; inverse interface, DataInput, DataOutput provides a higher-level, typed-stream approach to the reading and writing of data. Rather than dealing with bytes, this interface deals with writing the primitive types of the Java language directly:
<BR></P>
<PRE>void  write(int i)                                    throws IOException;
void  write(byte[]  buffer)                           throws IOException;
void  write(byte[]  buffer, int  offset, int  length) throws IOException;
void  writeBoolean(boolean b) throws IOException;
void  writeByte(int i)        throws IOException;
void  writeShort(int i)       throws IOException;
void  writeChar(int i)        throws IOException;
void  writeInt(int i)         throws IOException;
void  writeLong(long l)       throws IOException;
void  writeFloat(float f)     throws IOException;
void  writeDouble(double d)   throws IOException;
void  writeBytes(String s) throws IOException;
void  writeChars(String s) throws IOException;
void  writeUTF(String s)   throws IOException;</PRE>
<P>Most of these methods have counterparts in the interface DataInput.
<BR></P>
<P>The first three methods mirror the three forms of write() you saw previously. Each of the next eight methods write out a primitive type. The final three methods write out a string of bytes or characters to the stream: the first one as 8-bit bytes; the second, as 16-bit Unicode characters; and the last, as a special Unicode stream (readable by DataInput's readUTF()).
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note: </B>The unsigned read methods in DataInput have no counterparts here. You can write out the data they need via DataOutput's signed methods because they accept int arguments and also because they write out the correct number of bits for the unsigned integer of a given size as a side effect of writing out the signed integer of that same size. It is the method that reads this integer that must interpret the sign bit correctly; the writer's job is easy.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>Now that you know what the interface that DataOutputStream implements looks like, let's see it in action:
<BR></P>
<PRE>DataOutputStream  s    = new DataOutputStream(getNumericOutputStream());
long              size = getNumberOfItemsInNumericStream();
s.writeLong(size);
for (int  i = 0;  i &lt; size;  ++i) {
    if (shouldProcessNumber(i)) {
        s.writeBoolean(true);     // should process this item
        s.writeInt(theIntegerForItemNumber(i));
        s.writeShort(theMagicBitFlagsForItemNumber(i));
        s.writeDouble(theDoubleForItemNumber(i));
    } else
        s.writeBoolean(false);
}</PRE>
<P>This is the exact inverse of the example that was given for DataInput. Together, they form a pair that can communicate a particular array of structured primitive types across any stream (or &quot;transport layer&quot;). Use this pair as a jumping-off point whenever you need to do something similar.
<BR></P>
<P>In addition to the interface above, the class itself implements one (self-explanatory) utility method:
<BR></P>
<PRE>int  theNumberOfBytesWrittenSoFar = s.size();</PRE>
<H6>
<foNT SIZE=3><B>Processing a File</B>
<BR></FONT></H6>
<P>One of the <A ID = "I159" NAME = "I159"  ></A><A ID = "I160" NAME = "I160"  ></A><A ID = "I161" NAME = "I161"  ></A>most common idioms in file I/O is to <A ID = "I162" NAME = "I162"  ></A><A ID = "I163" NAME = "I163"  ></A>open a file, read and process it line-by-line, and output it again to another file. Here's a prototypical example of how that would be done in Java:
<BR></P>
<PRE>DataInput   aDI = new DataInputStream(new FileInputStream(&quot;source&quot;));
DataOutput  aDO = new DataOutputStream(new FileOutputStream(&quot;dest&quot;));
String      line;
while ((line = aDI.readLine()) != null) {
    StringBuffer  modifiedLine = new StringBuffer(line);
    . . .      // process modifiedLine in place
    aDO.writeBytes(modifiedLine.toString());
}
aDI.close();
aDO.close();</PRE>
<P>If you want to process it byte-by-byte, use this:
<BR></P>
<PRE>try {
    while (true) {
        byte  b = (byte) aDI.readByte();
        . . .      // process b in place
        aDO.writeByte(b);
    }
} finally {
    aDI.close();
    aDO.close();
}</PRE>
<P>Here's a cute two-liner that just copies the file:
<BR></P>
<PRE>try { while (true) aDO.writeByte(aDI.readByte()); }
finally { aDI.close(); aDO.close(); }</PRE>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="caution.gif" tppabs="http://newdata.box.sk/bx/java/caution.gif" WIDTH = 37 HEIGHT = 35><B>Caution: </B>Many of the examples in today's lesson (and the last two) assume that they appear inside a method that has IOException in its throws clause, so they don't have to &quot;worry&quot; about catching those exceptions and handling them more reasonably. Your code should be a little less cavalier.
<BR></NOTE>
<HR ALIGN=CENTER>
<H5><A ID = "I164" NAME = "I164"  >
<foNT SIZE=3><B>PrintStream</B>
<BR></FONT></A></H5>
<P>You may not realize it, <A ID = "I165" NAME = "I165"  ></A><A ID = "I166" NAME = "I166"  ></A>but you're already intimately familiar with the use of two methods of the PrintStream class. That's because whenever you use these method calls:
<BR></P>
<PRE>System.out.print(. . .)
System.out.println(. . .)</PRE>
<P>you are actually using a PrintStream instance located in System's class variable out to perform the output. System.err is also a PrintStream, and System.in is an InputStream.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note:</B> On UNIX systems, these three streams will be attached to standard output, standard error, and standard input, respectively.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>PrintStream is uniquely an output stream class (it has no &quot;brother&quot;). Because it is usually attached to a screen output device of some kind, it provides an implementation of flush(). It also provides the familiar close() and write() methods, as well as a plethora of choices for outputting the primitive types and Strings of Java:
<BR></P>
<PRE>public void  write(int b);
public void  write(byte[]  buffer, int  offset, int  length);
public void  flush();
public void  close();
public void  print(Object o);
public void  print(String s);
public void  print(char[]  buffer);
public void  print(char c);
public void  print(int i);
public void  print(long l);
public void  print(float f);
public void  print(double d);
public void  print(boolean b);
public void  println(Object o);
public void  println(String s);
public void  println(char[]  buffer);
public void  println(char c);
public void  println(int i);
public void  println(long l);
public void  println(float f);
public void  println(double d);
public void  println(boolean b);
public void  println();   // output a blank line</PRE>
<P>PrintStream can also be wrapped around any output stream, just like a filter class:
<BR></P>
<PRE>PrintStream  s = new PrintStream(new FileOutputStream(&quot;foo&quot;));
s.println(&quot;Here's the first line of text in the file foo.&quot;);</PRE>
<P>If you provide a second argument to the constructor for PrintStream, it is a boolean that specifies whether the stream should auto-flush. If true, a flush() is sent after each character is written (or for the three-argument form of write(), after a whole group of characters has been written.)
<BR></P>
<P>Here's a simple example program that operates like the UNIX command cat, taking the standard input, line-by-line, and outputting it to the standard output:
<BR></P>
<PRE>import java.io.*;   // the one time in the chapter we'll say this
public class  Cat {
    public static void  main(String argv[]) {
        DataInput  d = new DataInputStream(System.in);
        String     line;
     try {  while ((line = d.readLine()) != null)
            System.out.println(line);
        } catch (IOException  ignored) { }
    }
}</PRE>
<H4><A ID = "I167" NAME = "I167"  >
<foNT SIZE=3><B>PipedOutputStream</B>
<BR></FONT></A></H4>
<P>Along with PipedInputStream<A ID = "I168" NAME = "I168"  ></A><A ID = "I169" NAME = "I169"  ></A>, this pair of classes supports a UNIX-pipe-like connection between two threads, implementing all the careful synchronization that allows this sort of &quot;shared queue&quot; to operate safely. To set up the connection:
<BR></P>
<PRE>PipedInputStream   sIn  = PipedInputStream();
PipedOutputStream  sOut = PipedOutputStream(sIn);</PRE>
<P>One thread writes to sOut, and the other reads from sIn. By setting up two such pairs, the threads can communicate safely in both directions.
<BR></P>
<H3><A ID = "I170" NAME = "I170"  >
<foNT SIZE=4><B>Related Classes</B>
<BR></FONT></A></H3>
<P>The other classes and interfaces in java.io supplement the streams to provide a complete I/O system. Three of them are described below.
<BR></P>
<P>The File class <A ID = "I171" NAME = "I171"  ></A><A ID = "I172" NAME = "I172"  ></A>abstracts &quot;file&quot; in a platform-independent way. Given a filename, it can respond to queries about the type, status, and properties of a file or directory in the file system.
<BR></P>
<P>A RandomAccessFile<A ID = "I173" NAME = "I173"  ></A><A ID = "I174" NAME = "I174"  ></A> is created given a file, a filename, or a file descriptor. It combines in one class implementations of the DataInput and DataOutput interfaces, both tuned for &quot;random access&quot; to a file in the file system. In addition to these interfaces, RandomAccessFile provides certain traditional UNIX-like facilities, such as seek()ing to a random point in the file.
<BR></P>
<P>Finally, the StreamTokenizer<A ID = "I175" NAME = "I175"  ></A><A ID = "I176" NAME = "I176"  ></A> class takes an input stream and produces a sequence of tokens. By overriding its various methods in your own subclasses, you can create powerful lexical parsers.
<BR></P>
<P>You can learn more about any and all of these other classes from the full (online) API descriptions in your Java release.
<BR></P>
<H3><A ID = "I177" NAME = "I177"  >
<foNT SIZE=4><B>Summary</B>
<BR></FONT></A></H3>
<P>Today, you learned about the general idea of streams and met input streams based on byte arrays, files, pipes, sequences of other streams, and string buffers, as well as input filters for buffering, typed data, line numbering, and pushing-back characters.
<BR></P>
<P>You also met the analogous &quot;brother&quot; output streams for byte arrays, files, and pipes, and output filters for buffering and typed data, and the unique output filter used for printing.
<BR></P>
<P>Along the way, you became familiar with the fundamental methods all streams understand (such as read() and write()), as well as the unique methods many streams add to this repertoire. You learned about catching IOExceptions&#151;especially the most useful of them, EOFException.
<BR></P>
<P>Finally, the twice-useful DataInput and DataOutput interfaces formed the heart of RandomAccessFile, one of the several utility classes that round out Java's I/O facilities.
<BR></P>
<P>Java streams provide a powerful base on which you can build multithreaded, streaming interfaces of the most complex kinds, and the programs (such as HotJava) to interpret them. The higher-level Internet protocols and services of the future that your applets can build upon this base are really limited only by your imagination.
<BR></P>
<H3><A ID = "I178" NAME = "I178"  >
<foNT SIZE=4><B>Q&amp;A</B>
<BR></FONT></A></H3>
<P><B>Q: In an early </B><B>read()</B><B> example, you did something with the variable </B><B>byteOrMinus1</B><B> that seemed a little clumsy. Isn't there a better way? If </B><B>not, why recommend the cast later?</B>
<BR></P>
<P>A: Yes, there is something a little odd about those statements. You might be tempted to try something like this instead:
<BR>
<BR>while ((b = (byte) s.read()) != -1) {
<BR>    . . .    // process the byte b
<BR>}
<BR>
<BR>The problem with this short-cut occurs when read() returns the value 0xFF (0377). Since this value is signed-extended before the test gets executed, it will appear to be identical to the integer value -1 that indicates end of stream. Only saving that value in a separate integer variable, and then casting it later, will accomplish the desired result. The cast to byte is recommended in the note for orthogonal reasons&#151;storing integer values in correctly sized variables is always good style (and besides, read() really should be returning something of byte size here and throwing an exception for end of stream).
<BR></P>
<P><B>Q: What input streams in </B><B>java.io</B><B> actually implement </B><B>mark()</B><B>,c, and </B><B>markSupported()</B><B>?</B>
<BR></P>
<P><B>A: </B>InputStream itself does&#151;and in their default implementations, markSupported() returns false, mark() does nothing, and reset() throws an exception. The only input stream in the current release that correctly supports marking is BufferedInputStream, which overrides these defaults. LineNumberInputStream actually implements mark() and reset(), but in the current release, it doesn't answer markSupported() correctly, so it looks as if it does not.
<BR></P>
<P><B>Q: Why is </B><B>available()</B><B> useful, if it sometimes gives the wrong answer? </B>
<BR></P>
<P><B>A: </B>First, for many streams, it gives the right answer. Second, for some network streams, its implementation might be sending a special query to discover some information you couldn't get any other way (for example, the size of a file being transferred by ftp). If you were displaying a &quot;progress bar&quot; for network or file transfers, for example, available() will often give you the total size of the transfer, and when it does not&#151;usually by returning 0&#151;it will be obvious to you (and your users).
<BR></P>
<P><B>Q: What's a good example use of the </B><B>DataInput/DataOutput</B><B> pair of </B><B>interfaces?</B>
<BR></P>
<P><B>A: </B>One common use of such a pair is when objects want to &quot;pickle&quot; themselves for storage or movement over a network. Each object implements read and write methods using these interfaces, effectively converting itself to a stream that can later be reconstituted &quot;on the other end&quot; into a copy of the original object.
<BR></P>
<P><A HREF = "tyj18x.html" tppabs="http://newdata.box.sk/bx/java/tyj18x.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="blutoc.gif" tppabs="http://newdata.box.sk/bx/java/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF = "htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html"  ><IMG SRC="bluindex.gif" tppabs="http://newdata.box.sk/bx/java/bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF = "tyj20x.html" tppabs="http://newdata.box.sk/bx/java/tyj20x.html"  ><IMG SRC="blunext.gif" tppabs="http://newdata.box.sk/bx/java/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>
</P></BODY></HTML>
