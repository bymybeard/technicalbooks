<HTML>
<HEAD>
<TITLE>Teach Yourself Java in 21 Days tyj04x.htm</TITLE>
<LINK REL="ToC" HREF="httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html">
<LINK REL="Index" HREF="htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html">
<LINK REL="Next" HREF="tyj05x.html" tppabs="http://newdata.box.sk/bx/java/tyj05x.html">
<LINK REL="Previous" HREF="tyj03x.html" tppabs="http://newdata.box.sk/bx/java/tyj03x.html"></HEAD>
<BODY TEXT="#000000" LINK="#0000FF" VLINK="#800080" BACKGROUND="yellzig.gif" tppabs="http://newdata.box.sk/bx/java/yellzig.gif">

<P><A HREF = "tyj03x.html" tppabs="http://newdata.box.sk/bx/java/tyj03x.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="blutoc.gif" tppabs="http://newdata.box.sk/bx/java/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF = "htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html"  ><IMG SRC="bluindex.gif" tppabs="http://newdata.box.sk/bx/java/bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF = "tyj05x.html" tppabs="http://newdata.box.sk/bx/java/tyj05x.html"  ><IMG SRC="blunext.gif" tppabs="http://newdata.box.sk/bx/java/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>
</P><UL>
<LI>
<A HREF = "#I1"  >Day 4</A></LI>
<UL>
<LI>
<A HREF = "#I2"  >Working with Objects</A></LI>
<UL>
<LI>
<A HREF = "#I4"  >Creating New Objects</A></LI>
<UL>
<LI>
<A HREF = "#I10"  >Using new</A></LI>
<LI>
<A HREF = "#I15"  >What new Does</A></LI>
<LI>
<A HREF = "#I20"  >A Note on Memory Management</A></LI></UL>
<LI>
<A HREF = "#I22"  >Accessing and Setting Class and Instance Variables</A></LI>
<UL>
<LI>
<A HREF = "#I23"  >Getting Values</A></LI>
<LI>
<A HREF = "#I29"  >Changing Values</A></LI>
<LI>
<A HREF = "#I33"  >Class Variables</A></LI></UL>
<LI>
<A HREF = "#I44"  >Calling Methods</A></LI>
<UL>
<LI>
<A HREF = "#I54"  >Class Methods</A></LI></UL>
<LI>
<A HREF = "#I60"  >References to Objects</A></LI>
<LI>
<A HREF = "#I64"  >Casting and Converting Objects and Primitive Types</A></LI>
<UL>
<LI>
<A HREF = "#I66"  >Casting Primitive Types</A></LI>
<LI>
<A HREF = "#I70"  >Casting Objects</A></LI>
<LI>
<A HREF = "#I75"  >Converting Primitive Types to Objects and Vice Versa</A></LI></UL>
<LI>
<A HREF = "#I79"  >Odds and Ends</A></LI>
<UL>
<LI>
<A HREF = "#I80"  >Comparing Objects</A></LI>
<LI>
<A HREF = "#I90"  >Determining the Class of an Object</A></LI></UL>
<LI>
<A HREF = "#I97"  >The Java Class Library</A></LI>
<LI>
<A HREF = "#I113"  >Summary</A></LI>
<LI>
<A HREF = "#I114"  >Q&amp;A</A></LI></UL></UL></UL>

<H1><A ID = "I1" NAME = "I1"  >
<BR>
<foNT SIZE=5><B>Day 4</B>
<BR></FONT></A></H1>
<H2><A ID = "I2" NAME = "I2"  >
<foNT SIZE=5><B>Working with Objects</B>
<BR></FONT></A></H2>
<P><B>by Laura Lemay</B>
<BR></P>
<P>Let's start today's lesson with an obvious statement: because Java is an object-oriented language, you're going to be dealing with a lot of objects. You'll create them, modify them, move them around, change their variables, call their methods, combine them with other objects&#151;and, of course, develop classes and use your own objects in the mix.
<BR></P>
<P>Today, therefore, you'll learn all about the Java object in its natural habitat. Today's topics include:
<BR></P>
<UL>
<LI>Creating instances of classes
<BR>
<BR></LI>
<LI><A ID = "I3" NAME = "I3"  ></A>Testing and modifying class and instance variables in your new instance
<BR>
<BR></LI>
<LI>Calling methods in that object
<BR>
<BR></LI>
<LI>Casting (converting) objects and other data types from one class to another
<BR>
<BR></LI>
<LI>Other odds and ends about working with objects
<BR>
<BR></LI>
<LI>An overview of the Java class libraries
<BR>
<BR></LI></UL>
<H3><A ID = "I4" NAME = "I4"  >
<foNT SIZE=4><B>Creating New Objects</B>
<BR></FONT></A></H3>
<P>When you write a Java program, you <A ID = "I5" NAME = "I5"  ></A><A ID = "I6" NAME = "I6"  ></A>define a set of classes. As you learned on Day 2, classes are templates for objects; for the most part, you merely use the class to create instances and then work with those instances. In this section, therefore, you'll learn how to create a new object from any given class.
<BR></P>
<P>Remember strings from <A ID = "I7" NAME = "I7"  ></A>yesterday? You learned that using a string literal&#151;a series of characters enclosed in double-quotes&#151;creates a new instance of the class String with the value of that string.
<BR></P>
<P>The String class is unusual <A ID = "I8" NAME = "I8"  ></A><A ID = "I9" NAME = "I9"  ></A>in that respect&#151;although it's a class, there's an easy way to create instances of that class using a literal. The other classes don't have that shortcut; to create instances of those classes you have to do so explicitly by using the new operator.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Note:</B> What about the literals for numbers and characters? Don't they create objects, too? Actually, they don't. The primitive data types for numbers and characters create numbers and characters, but for efficiency, they aren't actually objects. You can put object-wrappers around them if you need to treat them like objects (you'll learn how to do this later).
<BR></NOTE>
<HR ALIGN=CENTER>
<H4><A ID = "I10" NAME = "I10"  >
<foNT SIZE=3><B>Using </B><B>new</B>
<BR></FONT></A></H4>
<P>To create a new object, you <A ID = "I11" NAME = "I11"  ></A><A ID = "I12" NAME = "I12"  ></A>use new with the name of the class you want to create an instance of, then parentheses after that:
<BR></P>
<PRE>String str = new String();
Random r = new Random();
Motorcycle m2 = new Motorcycle();</PRE>
<P>The parentheses are <A ID = "I13" NAME = "I13"  ></A>important; don't leave them off. The parentheses can be empty, in which case the most simple, basic object is created, or the parentheses can contain arguments that determine the initial values of instance variables or other initial qualities of that object. The number and type of arguments you can use with new are defined by the class itself by using a special method called a constructor; you'll learn about how to create constructors in your own classes later on this week.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="caution.gif" tppabs="http://newdata.box.sk/bx/java/caution.gif" WIDTH = 37 HEIGHT = 35><B>Caution:</B> Some classes may not allow you to create instances without any arguments. Check the class to make sure.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>For example, take the Date class, which creates date objects. Listing 4.1 is a Java program that shows three different ways of creating a Date object using new:
<BR></P>
<UL>
<LH><B>Listing 4.1. Laura's </B><B>Date</B><B> program.</B><A ID = "I14" NAME = "I14"  ></A></LH></UL>
<PRE> 1: import java.util.Date;
 2: 
 3: class CreateDates {
 4: 
 5:     public static void main(String args[]) {
 6:         Date d1, d2, d3;
 7: 
 8:         d1 = new Date();
 9:         System.out.println(&quot;Date 1: &quot; + d1);
10: 
11:         d2 = new Date(71, 7, 1, 7, 30);
12:         System.out.println(&quot;Date 2: &quot; + d2);
13: 
14:         d3 = new Date(&quot;April 3 1993 3:24 PM&quot;);
15:         System.out.println(&quot;Date 3: &quot; + d3);
16:     }
17: }
Date 1: Tue Feb 13 09:36:56 PST 1996
Date 2: Sun Aug 01 07:30:00 PDT 1971
Date 3: Sat Apr 03 15:24:00 PST 1993</PRE>
<P>In this example, three different dates are created by using different arguments to new. The first instance (line 8) uses new with no arguments, which creates a Date object for today's date (as the first line of the output shows).
<BR></P>
<P>The second Date object you create in this example has five integer arguments. The arguments represent a date: year, month, day, hours, and seconds. And, as the output shows, this creates a Date object for that particular date: Sunday, August first, 1971, at 7:30 AM.
<BR></P>
<P>The third version of Date takes one argument, a string, representing the date as a text string. When the Date object is created, that string is parsed, and a Date object with that date and time is created (see the third line of output). The date string can take many different formats; see the API documentation for the Date class (part of the java.util package) for information about what strings you can use.
<BR></P>
<H4><A ID = "I15" NAME = "I15"  >
<foNT SIZE=3><B>What </B><B>new</B><B> Does</B>
<BR></FONT></A></H4>
<P>What does new do? When you use <A ID = "I16" NAME = "I16"  ></A><A ID = "I17" NAME = "I17"  ></A>the new operator, several things happen: first, the new instance of the given class is created, and memory is allocated for it. In addition (and most importantly), when the new object is created, a special method defined in the given class is called. This special method is called a constructor.
<BR></P>
<P><I>Constructors</I> are <A ID = "I18" NAME = "I18"  ></A><A ID = "I19" NAME = "I19"  ></A>special methods for creating and initializing new instances of classes. Constructors initialize the new object and its variables, create any other objects that object needs, and generally perform any other operations the object needs to initialize itself. 
<BR></P>
<P>Multiple constructor definitions in a class can each have a different number or type of arguments&#151;then, when you use new, you can specify different arguments in the argument list, and the right constructor for those arguments will be called. That's how each of those different versions of new that were listed previously can create different things.
<BR></P>
<P>When you create your own classes, you can define as many constructors as you need to implement that class's behavior. You'll learn how to create constructors on Day 7.
<BR></P>
<H4><A ID = "I20" NAME = "I20"  >
<foNT SIZE=3><B>A Note on Memory Management</B>
<BR></FONT></A></H4>
<P>Memory management in Java <A ID = "I21" NAME = "I21"  ></A>is dynamic and automatic. When you create a new object in Java, Java automatically allocates the right amount of memory for that object in the heap. You don't have to allocate any memory for any objects explicitly; Java does it for you.
<BR></P>
<P>What happens when you're finished with that object? How do you de-allocate the memory that object uses? The answer is again: memory management is automatic. Once you finish with an object, that object no longer has any live references to it (it won't be assigned to any variables you're still using or stored in any arrays). Java has a garbage collector that looks for unused objects and reclaims the memory that those objects are using. You don't have to do any explicit freeing of memory; you just have to make sure you're not still holding onto an object you want to get rid of. You'll learn more specific details about the Java garbage collector and how it works on Day 21.
<BR></P>
<H3><A ID = "I22" NAME = "I22"  >
<foNT SIZE=4><B>Accessing and Setting Class and Instance Variables</B>
<BR></FONT></A></H3>
<P>Now you have your very own object, and that object may have class or instance variables defined in it. How do you work with those variables? Easy! Class and instance variables behave in exactly the same ways as the local variables you learned about yesterday; you just refer to them slightly differently than you do regular variables in your code.
<BR></P>
<H4><A ID = "I23" NAME = "I23"  >
<foNT SIZE=3><B>Getting Values</B>
<BR></FONT></A></H4>
<P>To get to the value <A ID = "I24" NAME = "I24"  ></A><A ID = "I25" NAME = "I25"  ></A><A ID = "I26" NAME = "I26"  ></A>of an instance variable, you use dot notation. 
<BR></P>
<P>With <I>dot notation</I>, an <A ID = "I27" NAME = "I27"  ></A>instance or class variable name has two parts: the object on the left side of the dot, and the variable on the right side of the dot.
<BR></P>
<P>For example, if you have an object assigned to the variable myObject, and that object has a variable called var, you refer to that variable's value like this:
<BR></P>
<PRE>myObject.var;</PRE>
<P>This form for accessing variables <A ID = "I28" NAME = "I28"  ></A>is an expression (it returns a value), and both sides of the dot are also expressions. This means that you can nest instance variable access. If that var instance variable itself holds an object, and that object has its own instance variable called state, you can refer to it like this:
<BR></P>
<PRE>myObject.var.state;</PRE>
<P>Dot expressions are evaluated left to right, so you start with myObject's variable var, which points to another object with the variable state. You end up with the value of that state variable.
<BR></P>
<H4><A ID = "I29" NAME = "I29"  >
<foNT SIZE=3><B>Changing Values</B>
<BR></FONT></A></H4>
<P>Assigning a value <A ID = "I30" NAME = "I30"  ></A><A ID = "I31" NAME = "I31"  ></A>to that variable is equally easy&#151;just tack an assignment operator on the right side of the expression:
<BR></P>
<PRE>myObject.var.state = true;</PRE>
<P>Listing 4.2 is an example of a program that tests and modifies the instance variables in a Point object. Point is part of the java.awt package and refers to a coordinate point with an x and a y value.
<BR></P>
<UL>
<LH><B>Listing 4.2. The </B><B>TestPoint</B><B> Class.</B><A ID = "I32" NAME = "I32"  ></A></LH></UL>
<PRE> 1: import java.awt.Point;
 2: 
 3: class TestPoint {
 4: 
 5:     public static void main(String args[]) {
 6:         Point thePoint = new Point(10,10);
 7: 
 8:         System.out.println(&quot;X is &quot; + thePoint.x);
 9:         System.out.println(&quot;Y is &quot; + thePoint.y);
10: 
11:         System.out.println(&quot;Setting X to 5.&quot;);
12:         thePoint.x = 5;
13:         System.out.println(&quot;Setting Y to 15.&quot;);
14:         thePoint.y = 15;
15: 
16:         System.out.println(&quot;X is &quot; + thePoint.x);
17:         System.out.println(&quot;Y is &quot; + thePoint.y);
18: 
19:     }
20: }
X is 10
Y is 10
Setting X to 5.
Setting Y to 15.
X is 5
Y is 15</PRE>
<P>In this example, you first create an instance of Point where X and Y are both 10 (line 6). Lines 8 and 9 print out those individual values, and you can see dot notation at work there. Lines 11 through 14 change the values of those variables to 5 and 15, respectively. Finally, lines 16 and 17 print out the values of X and Y again to show how they've changed.
<BR></P>
<H4><A ID = "I33" NAME = "I33"  >
<foNT SIZE=3><B>Class Variables</B>
<BR></FONT></A></H4>
<P>Class variables, as you <A ID = "I34" NAME = "I34"  ></A><A ID = "I35" NAME = "I35"  ></A>learned before, are variables that are defined and stored in the class itself. Their values, therefore, apply to the class and to all its instances.
<BR></P>
<P>With instance variables, each new instance of the class gets a new copy of the instance variables that class defines. Each instance can then change the values of <A ID = "I36" NAME = "I36"  ></A><A ID = "I37" NAME = "I37"  ></A>those instance variables without affecting any other instances. With class variables, there is only one copy of that variable. Every instance of the class has access to that variable, but there is only one value. Changing the value of that variable changes it for all the instances of that class.
<BR></P>
<P>You define class variables by <A ID = "I38" NAME = "I38"  ></A><A ID = "I39" NAME = "I39"  ></A><A ID = "I40" NAME = "I40"  ></A>including the static keyword before the variable itself. You'll learn more about this on Day 6. For example, take the following partial class definition:
<BR></P>
<PRE>class FamilyMember {
    static String surname = &quot;Johnson&quot;;
    String name;
    int age;
    ...
}</PRE>
<P>Instances of the class FamilyMember each have their own values for name and age. But the class variable surname has only one value for all family members. Change surname, and all the instances of FamilyMember are affected.
<BR></P>
<P>To access class <A ID = "I41" NAME = "I41"  ></A><A ID = "I42" NAME = "I42"  ></A><A ID = "I43" NAME = "I43"  ></A>variables, you use the same dot notation as you do with instance variables. To get or change the value of the class variable, you can use either the instance or the name of the class on the left side of the dot. Both the lines of output in this example print the same value):
<BR></P>
<PRE>FamilyMember dad = new FamilyMember()
System.out.println(&quot;Family's surname is: &quot; + dad.surname);
System.out.println(&quot;Family's surname is: &quot; + FamilyMember.surname);</PRE>
<P>Because you can use an instance to change the value of a class variable, it's easy to become confused about class variables and where their values are coming from (remember, the value of a class variable affects all the instances). For this reason, it's a good idea to use the name of the class when you refer to a class variable&#151;it makes your code easier to read and strange results easier to debug.
<BR></P>
<H3><A ID = "I44" NAME = "I44"  >
<foNT SIZE=4><B>Calling Methods</B>
<BR></FONT></A></H3>
<P>Calling a method in <A ID = "I45" NAME = "I45"  ></A><A ID = "I46" NAME = "I46"  ></A>objects is similar to referring to its instance variables: method calls also use <A ID = "I47" NAME = "I47"  ></A>dot notation. The object whose method you're calling is on the left side of the dot; the name of the method and its arguments is on the right side of the dot:
<BR></P>
<PRE>myObject.methodOne(arg1, arg2, arg3);</PRE>
<P>Note that all methods must <A ID = "I48" NAME = "I48"  ></A><A ID = "I49" NAME = "I49"  ></A>have parentheses after them, even if that method takes no arguments:
<BR></P>
<PRE>myObject.methodNoArgs();</PRE>
<P>If the method you've called results in an object that itself has methods, you can nest methods as you would variables:
<BR></P>
<PRE>myObject.getClass().getName();</PRE>
<P>You can combine nested <A ID = "I50" NAME = "I50"  ></A><A ID = "I51" NAME = "I51"  ></A><A ID = "I52" NAME = "I52"  ></A>method calls and instance variable references as well:
<BR></P>
<PRE>myObject.var.methodTwo(arg1, arg2);</PRE>
<P>System.out.println(), the method you've been using all through the book this far, is a great example of nesting variables and methods. The System class (part of the java.lang package) describes system-specific behavior. System.out is a class variable that contains an instance of the class PrintStream that points to the standard output of the system. PrintStream instances have a println() method that prints a string to that output stream. 
<BR></P>
<P>Listing 4.3 shows an example of calling some methods defined in the String class. Strings include methods for string tests and modification, similar to what you would expect in a string library in other languages.
<BR></P>
<UL>
<LH><B>Listing 4.3. Several Uses of </B><B>String</B><B> methods.</B><A ID = "I53" NAME = "I53"  ></A></LH></UL>
<PRE> 1: class TestString {
 2: 
 3:     public static void main(String args[]) {
 4:         String str = &quot;Now is the winter of our discontent&quot;;
 5: 
 6:         System.out.println(&quot;The string is: &quot; + str);
 7:         System.out.println(&quot;Length of this string: &quot;
 8:                 + str.length());
 9:         System.out.println(&quot;The character at position 5: &quot;
10:                 + str.charAt(5));
11:         System.out.println(&quot;The substring from 11 to 17: &quot;
12:                 + str.substring(11, 17));
13:         System.out.println(&quot;The index of the character d: &quot;
14:                 + str.indexOf('d'));
15:         System.out.print(&quot;The index of the beginning of the &quot;);
16:         System.out.println(&quot;substring \&quot;winter\&quot;:&quot;
17:                 + str.indexOf(&quot;winter&quot;));
18:         System.out.println(&quot;The string in upper case: &quot;
19:                 + str.toUpperCase());
20:     }
21: }
The string is: Now is the winter of our discontent
Length of this string: 35
The character at position 5: s
The substring from positions 11 to 17: winter
The index of the character d: 25
The index of the beginning of the substring &quot;winter&quot;: 11
The string in upper case: NOW IS THE WINTER OF OUR DISCONTENT</PRE>
<P>In line 4, you create a new instance of String by using a string literal (it's easier that way than using new and then putting the characters in individually). The remainder of the program simply calls different string methods to do different operations on that string:
<BR></P>
<UL>
<LI>Line 6 prints the value of the string we created in line 4: &quot;Now is the winter of our discontent&quot;.
<BR>
<BR></LI>
<LI>Line 7 calls the length() method in the new String object. This string has 35 characters.
<BR>
<BR></LI>
<LI>Line 9 calls the charAt() method, which returns the character at the given position in the string. Note that string positions start at 0, so the character at position 5 is s.
<BR>
<BR></LI>
<LI>Line 11 calls the substring() method, which takes two integers indicating a range and returns the substring at those starting and ending points. The substring() method can also be called with only one argument, which returns the substring from that position to the end of the string.
<BR>
<BR></LI>
<LI>Line 13 calls the indexOf() method, which returns the position of the first instance of the given character (here, 'd').
<BR>
<BR></LI>
<LI>Line 15 shows a different use of the indexOf() method, which takes a string argument and returns the index of the beginning of that string.
<BR>
<BR></LI>
<LI>Finally, line 18 uses the toUpperCase() method to return a copy of the string in all uppercase.
<BR>
<BR></LI></UL>
<H4><A ID = "I54" NAME = "I54"  >
<foNT SIZE=3><B>Class Methods</B>
<BR></FONT></A></H4>
<P>Class methods, like <A ID = "I55" NAME = "I55"  ></A><A ID = "I56" NAME = "I56"  ></A>class variables, apply to the class as a whole and not to its instances. Class methods are commonly used for general utility methods that may not operate directly on an instance of that class, but fit with that class conceptually. For example, the String class contains a class method called valueOf(), which can take one of many different types of arguments (integers, booleans, other objects, and so on). The valueOf() method then returns a new instance of String containing the string value of the argument it was given. This method doesn't operate directly on an existing instance of String, but getting a string from another object or data type is definitely a String-like operation, and it makes sense to define it in the String class.
<BR></P>
<P>Class methods can also be useful for gathering general methods together in one place (the class). For example, the Math class, defined in the java.lang package, contains a large set of mathematical operations as class methods&#151;there are no instances of the class Math, but you can still use its methods with numeric or boolean arguments.
<BR></P>
<P>To call a class method, use <A ID = "I57" NAME = "I57"  ></A><A ID = "I58" NAME = "I58"  ></A><A ID = "I59" NAME = "I59"  ></A>dot notation as you do with instance methods. As with class variables, you can use either an instance of the class or the class itself on the left site of the dot. However, for the same reasons noted in the discussion on class variables, using the name of the class for class variables makes your code easier to read. The last two lines in this example produce the same result:
<BR></P>
<PRE>String s, s2;
s = &quot;foo&quot;;
s2 = s.valueOf(5);
s2 = String.valueOf(5);</PRE>
<H3><A ID = "I60" NAME = "I60"  >
<foNT SIZE=4><B>References to Objects</B>
<BR></FONT></A></H3>
<P>As you work <A ID = "I61" NAME = "I61"  ></A><A ID = "I62" NAME = "I62"  ></A>with objects, one important thing going on behind the scenes is the use of references to those objects. When you assign objects to variables, or pass objects as arguments to methods, you are passing references to those objects, not the objects themselves or copies of those objects.
<BR></P>
<P>An example should make this clearer. Examine the following snippet of code:
<BR></P>
<PRE>import java.awt.Point;
class ReferencesTest {
    public static void main (String args[]) {
        Point pt1, pt2;
        pt1 = new Point(100, 100);
        pt2 = pt1;
        pt1.x = 200;
        pt1.y = 200;
        System.out.println(&quot;Point1: &quot; + pt1.x + &quot;, &quot; + pt1.y);
        System.out.println(&quot;Point2: &quot; + pt2.x + &quot;, &quot; + pt2.y);
    }
}</PRE>
<P>In this program, you declare two variables of type Point, and assign a new Point object to pt1. Then you assign the value of pt1 to pt2.
<BR></P>
<P>Now, here's the challenge. After changing pt1's x and y instance variables, what will pt2 look like?
<BR></P>
<P>Here's the output of that program:
<BR></P>
<PRE>Point1: 200, 200
Point2: 200, 200</PRE>
<P>As you can see, pt2 was also changed. When you assign the value of pt1 to pt2, you actually create a reference from p2 to the same object to which pt1 refers. Change the object that pt2 refers to, and you also change the object that pt1 points to, because both are references to the same object.
<BR></P>
<P>The fact that Java uses references becomes particularly important when you pass arguments to methods. You'll learn more about this later on today, but keep these references in mind.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Technical Note:</B> There <A ID = "I63" NAME = "I63"  ></A>are no explicit pointers or pointer arithmetic in Java&#151;just references. However, with these references, and with Java arrays, you have most of the capabilities that you have with pointers without the confusion and lurking bugs that explicit pointers can create.
<BR></NOTE>
<HR ALIGN=CENTER>
<H3><A ID = "I64" NAME = "I64"  >
<foNT SIZE=4><B>Casting and Converting Objects and Primitive Types</B>
<BR></FONT></A></H3>
<P>Sometimes in your Java programs you may have a value stored somewhere that is the wrong type. Maybe it's an instance of the wrong class, or perhaps it's a float and you want it to be an int. To convert the value of one type to another, you use a mechanism called casting. 
<BR></P>
<P><I>Casting</I> is a mechanism <A ID = "I65" NAME = "I65"  ></A>of converting the value of an object or primitive type into another type. The result of a cast is a new reference or value; casting does not affect the original object or value. 
<BR></P>
<P>Although the concept of casting is a simple one, the rules for what types in Java can be converted to what other types are complicated by the fact that Java has both primitive types (int, float, boolean), and object types (String, Point, Window, and so on). There are three forms of casts and conversions to talk about in this section:
<BR></P>
<UL>
<LI>Casting between primitive types: int to float to boolean
<BR>
<BR></LI>
<LI>Casting between object types: an instance of a class to an instance of another class
<BR>
<BR></LI>
<LI>Converting primitive types to objects and then extracting primitive values back out of those objects
<BR>
<BR></LI></UL>
<H4><A ID = "I66" NAME = "I66"  >
<foNT SIZE=3><B>Casting Primitive Types</B>
<BR></FONT></A></H4>
<P>Casting between primitive <A ID = "I67" NAME = "I67"  ></A><A ID = "I68" NAME = "I68"  ></A>types enables you to &quot;convert&quot; the value of one type to another <A ID = "I69" NAME = "I69"  ></A>primitive type&#151;for example, to assign a number of one type to a variable of another type. Casting between primitive types most commonly occurs with the numeric types; boolean values cannot be cast to any other primitive type. 
<BR></P>
<P>Often, if the type you are casting to is &quot;larger&quot; than the type of the value you're converting, you may not have to use an explicit cast. You can often automatically treat a byte or a character as an int, for example, or an int as a long, an int as a float, or anything as a double automatically. In most cases, because the larger type provides more precision than the smaller, no loss of information occurs when the value is cast. The exception is casting integers to floating-point values; casting an int or a long to a float or a long to a double may cause some loss of precision.
<BR></P>
<P>To convert a large value to smaller type, you must use an explicit cast, because converting that value may result in a loss of precision. Explicit casts look like this:
<BR></P>
<PRE>(typename) value</PRE>
<P>In this form, <I>typename</I> is the name of the type you're converting to (for example: short, int, float, boolean), and <I>value</I> is an expression that results in the value you want to convert. This expression divides the values of x by the value of y and casts the result to an int:
<BR></P>
<PRE>(int) (x / y);</PRE>
<P>Note that because the precedence of casting is higher than that of arithmetic, you have to use parentheses so that the result of the division is what gets cast to an int.
<BR></P>
<H4><A ID = "I70" NAME = "I70"  >
<foNT SIZE=3><B>Casting Objects</B>
<BR></FONT></A></H4>
<P>Instances of classes <A ID = "I71" NAME = "I71"  ></A><A ID = "I72" NAME = "I72"  ></A>can also be cast to instances of other classes, with one restriction: the class of the object you're casting and the class you're casting it to must be related by inheritance; that is, you can cast an object only to an instance of its class's sub- or superclass&#151;not to any random class.
<BR></P>
<P>Analogous to converting a primitive value to a larger type, some objects may not need to be cast explicitly. In particular, because subclasses contain all the information in the superclass, you can use an instance of a subclass anywhere a superclass is expected. Suppose you have a method that takes two arguments: one of type Object, and one of type Number. You don't have to pass instances of those particular classes to that method. For the Object argument, you can pass any subclass of Object (any object, in other words), and for the Number argument you can pass in any instance of any subclass of Number (Integer, Boolean, Float, and so on).
<BR></P>
<P>Casting an object to an instance of one of that object's superclasses loses the information the original subclass provided and requires a specific cast. To <A ID = "I73" NAME = "I73"  ></A><A ID = "I74" NAME = "I74"  ></A>cast an object to another class, you use the same casting operation that you used for base types:
<BR></P>
<PRE>(classname) object</PRE>
<P>In this case, <I>classname</I> is the name of the class you want to cast the object to, and object is a reference to the object you're casting. Note that casting creates a reference to the old object of the type classname; the old object still continues to exist as it did before.
<BR></P>
<P>Here's a (fictitious) example of a cast of an instance of the class GreenApple to an instance of the class Apple (where GreenApple is theoretically a subclass of Apple): 
<BR></P>
<PRE>GreenApple a;
Apple a2;
a = new GreenApple();
a2 = (Apple) a;</PRE>
<P>In addition to casting objects to classes, you can also cast objects to interfaces&#151;but only if that object's class or one of its superclasses actually implements that interface. Casting an object to an interface then enables you to call one of that interface's methods even if that object's class does not directly implement that interface. You'll learn more about interfaces in Week 3.
<BR></P>
<H4><A ID = "I75" NAME = "I75"  >
<foNT SIZE=3><B>Converting Primitive Types to Objects and Vice Versa</B>
<BR></FONT></A></H4>
<P>Now you know how to cast <A ID = "I76" NAME = "I76"  ></A><A ID = "I77" NAME = "I77"  ></A><A ID = "I78" NAME = "I78"  ></A>a primitive type to another primitive type and how to cast between classes. How can you cast one to the other?
<BR></P>
<P>You can't! Primitive types and objects are very different things in Java and you can't automatically cast or convert between the two. However, the java.lang package includes several special classes that correspond to each primitive data type: Integer for ints, Float for floats, Boolean for booleans, and so on. 
<BR></P>
<P>Using class methods defined in these classes, you can create an object-equivalent for all the primitive types using new. The following line of code creates an instance of the Integer class with the value 35:
<BR></P>
<PRE>Integer intObject = new Integer(35);</PRE>
<P>Once you have actual objects, you can treat those values as objects. Then, when you want the primitive values back again, there are methods for that as well&#151;for example, the intValue() method extracts an int primitive value from an Integer object:
<BR></P>
<PRE>int theInt = intObject.intValue();  // returns 35</PRE>
<P>See the Java API documentation for these special classes for specifics on the methods for converting primitives to and from objects.
<BR></P>
<H3><A ID = "I79" NAME = "I79"  >
<foNT SIZE=4><B>Odds and Ends</B>
<BR></FONT></A></H3>
<P>This section is a catch-all for other information about working with objects, in particular:
<BR></P>
<UL>
<LI>Comparing objects
<BR>
<BR></LI>
<LI>Copying objects
<BR>
<BR></LI>
<LI>Finding out the class of any given object
<BR>
<BR></LI>
<LI>Testing to see whether an object is an instance of a given class
<BR>
<BR></LI></UL>
<H4><A ID = "I80" NAME = "I80"  >
<foNT SIZE=3><B>Comparing Objects</B>
<BR></FONT></A></H4>
<P>Yesterday, you learned <A ID = "I81" NAME = "I81"  ></A><A ID = "I82" NAME = "I82"  ></A>about operators for comparing values: equals, not equals, less than, and so on. Most of these operators work only on primitive types, not on objects. If you try to use other values as operands, the Java compiler produces errors.
<BR></P>
<P>The exception to this rule is with the operators for equality: == (equal) and != (not  equal). These operators, when used with objects, tests whether the two operands refer to exactly the same object.
<BR></P>
<P>What should you do if you want to be able to compare instances of your class and have meaningful results? You have to implement special methods in your class, and you have to call those methods using those method names. 
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Technical Note:</B> Java does not have the concept of <A ID = "I83" NAME = "I83"  ></A><A ID = "I84" NAME = "I84"  ></A>operator overloading&#151;that is, the capability of defining the behavior of the built-in operators by defining methods in your own classes. The built-in operators remain defined only for numbers.
<BR></NOTE>
<HR ALIGN=CENTER>
<P>A good example of this is the String class. It is possible to have two strings, two independent objects in memory with the same values&#151;that is, the same characters in the same order. According to the == operator, however, those two String objects will not be equal, because, although their contents are the same, they are not the same object.
<BR></P>
<P>The String class, therefore, defines a method called equals() that tests each character in the string and returns true if the two strings have the same values. Listing 4.4 illustrates this.
<BR></P>
<UL>
<LH><B>Listing 4.4. A Test of String Equality.</B><A ID = "I85" NAME = "I85"  ></A></LH></UL>
<PRE> 1: class EqualsTest {
 2: 
 3:     public static void main(String args[]) {
 4:         String str1, str2;
 5:         str1 = &quot;she sells sea shells by the sea shore.&quot;;
 6:         str2 = str1;
 7: 
 8:         System.out.println(&quot;String1: &quot; + str1);
 9:         System.out.println(&quot;String2: &quot; + str2);
10:         System.out.println(&quot;Same object? &quot; + (str1 == str2));
11: 
12:         str2 = new String(str1);
13: 
14:         System.out.println(&quot;String1: &quot; + str1);
15:         System.out.println(&quot;String2: &quot; + str2);
16:         System.out.println(&quot;Same object? &quot; + (str1 == str2));
17:         System.out.println(&quot;Same value? &quot; + str1.equals(str2));
18:     }
19: }
String1: she sells sea shells by the sea shore.
String2: she sells sea shells by the sea shore.
Same object? true
String1: she sells sea shells by the sea shore.
String2: she sells sea shells by the sea shore.
Same object? false
Same value? true</PRE>
<P>The first part of this <A ID = "I86" NAME = "I86"  ></A><A ID = "I87" NAME = "I87"  ></A><A ID = "I88" NAME = "I88"  ></A><A ID = "I89" NAME = "I89"  ></A>program (lines 4 through 6) declares two variables, str1 and str2, assigns the literal she sells sea shells by the sea shore. to str1, and then assigns that value to str2. As you know from object references, now str1 and str2 point to the same object, and the test at line 10 proves that.
<BR></P>
<P>In the second part, you create a new string object with the value of str1. Now you have two different string objects with the same value. Testing them to see whether they're the same object by using the == operator (line 16) returns the expected answer, as does testing them using the equals method (line 17) to compare their values.
<BR></P>
<HR ALIGN=CENTER>
<NOTE>
<IMG SRC="note.gif" tppabs="http://newdata.box.sk/bx/java/note.gif" WIDTH = 35 HEIGHT = 35><B>Technical Note:</B> Why can't you just use another literal when you change str2, rather than using new? String literals are optimized in Java&#151;if you create a string using a literal, and then use another literal with the same characters, Java knows enough to give you the first String object back. Both strings are the same objects&#151;to create two separate objects you have to go out of your way.
<BR></NOTE>
<HR ALIGN=CENTER>
<H4><A ID = "I90" NAME = "I90"  >
<foNT SIZE=3><B>Determining the Class of an Object</B>
<BR></FONT></A></H4>
<P>Want to find out <A ID = "I91" NAME = "I91"  ></A><A ID = "I92" NAME = "I92"  ></A>the class of an object? Here's the way to do it for an object assigned to the variable obj:
<BR></P>
<PRE>String name = obj.getClass().getName();</PRE>
<P>What does this do? The getClass() <A ID = "I93" NAME = "I93"  ></A><A ID = "I94" NAME = "I94"  ></A>method is defined in the Object class, and as such is available for all objects. The result of that method is a Class object (where Class is itself a class), which has a method called getName(). getName() returns a string representing the name of the class.
<BR></P>
<P>Another test that might be useful to you is the instanceof operator. instanceof has two <A ID = "I95" NAME = "I95"  ></A><A ID = "I96" NAME = "I96"  ></A>operands: an object on the left, and the name of a class on the right. The expression returns true or false based on whether the object is an instance of the named class or any of that class's subclasses:
<BR></P>
<PRE>&quot;foo&quot; instanceof String // true
Point pt = new Point(10, 10);
pt instanceof String // false</PRE>
<P>The instanceof operator can also be used for interfaces; if an object implements an interface, the instanceof operator with that interface name on the right side returns true. You'll learn all about interfaces in Week 3.
<BR></P>
<H3><A ID = "I97" NAME = "I97"  >
<foNT SIZE=4><B>The Java Class Library</B>
<BR></FONT></A></H3>
<P>To finish up today, let's look at <A ID = "I98" NAME = "I98"  ></A><A ID = "I99" NAME = "I99"  ></A>the some of the Java class library. Actually, you've had some experience with them already, so they shouldn't seem that strange.
<BR></P>
<P>The Java class library provides the set of classes that are guaranteed to be available in any commercial Java environment (for example, in HotJava or in Netscape 2.0). Those classes are in the java package and include all the classes you've seen so far in this book, plus a whole lot more classes you'll learn about later on in this book (and more you won't learn about at all).
<BR></P>
<P>The Java Developer's Kit <A ID = "I100" NAME = "I100"  ></A><A ID = "I101" NAME = "I101"  ></A>comes with documentation for all of the Java class library, which includes descriptions of each class's instance variables, methods, constructors, interfaces, and so on. A shorter summary of the Java API is in Appendix C as well. Exploring the Java class library and its methods and instance variables is a great way to figure out what Java can and cannot do, as well as a starting point for your own development.
<BR></P>
<P>Here are the class packages that are part of the Java class library:
<BR></P>
<UL>
<LI>java.lang: Classes that apply <A ID = "I102" NAME = "I102"  ></A><A ID = "I103" NAME = "I103"  ></A>to the language itself, which includes the Object class, the String class, and the System class. It also contains the special classes for the primitive types (Integer, Character, Float, and so on).
<BR>
<BR></LI>
<LI>java.util: Utility classes, such <A ID = "I104" NAME = "I104"  ></A><A ID = "I105" NAME = "I105"  ></A>as Date, as well as simple collection classes, such as Vector and Hashtable.
<BR>
<BR></LI>
<LI>java.io:<I> </I>Input and output classes <A ID = "I106" NAME = "I106"  ></A><A ID = "I107" NAME = "I107"  ></A>for writing to and reading from streams (such as standard input and output) and for handling files.
<BR>
<BR></LI>
<LI>java.net:<I> </I>Classes for <A ID = "I108" NAME = "I108"  ></A><A ID = "I109" NAME = "I109"  ></A>networking support, including Socket and URL (a class to represent references to documents on the World Wide Web).
<BR>
<BR></LI>
<LI>java.awt:<I> (the Abstract Window Toolkit): </I>Classes to <A ID = "I110" NAME = "I110"  ></A>implement a graphical user interface, including classes for Window, Menu, Button, Font, CheckBox, and so on. This package also includes classes for processing images (in the java.awt.Image package).
<BR>
<BR></LI>
<LI>java.applet:<I> </I>Classes to <A ID = "I111" NAME = "I111"  ></A><A ID = "I112" NAME = "I112"  ></A>implement Java applets, including the Applet class itself, as well as the AudioClip interface.
<BR>
<BR></LI></UL>
<P>In addition to the Java classes, your development environment may also include additional classes that provide other utilities or functionality. Although these classes may be useful, because they are not part of the standard Java library, they won't be available to other people trying to run your Java program. This is particularly important for applets, because applets are expected to be able to run on any platform, using any Java-capable browser. Only classes inside the java package are guaranteed to be available on all browsers and Java environments.
<BR></P>
<H3><A ID = "I113" NAME = "I113"  >
<foNT SIZE=4><B>Summary</B>
<BR></FONT></A></H3>
<P>Objects, objects everywhere. Today, you learned all about how to deal with objects: how to create them, how to find out and change the values of their variables, and how to call their methods. You also learned how to copy and compare them, and how to convert them into other objects. Finally, you learned a bit about the Java class libraries&#151;which give you a whole slew of classes to play with in your own programs.
<BR></P>
<P>You now have the fundamentals of how to deal with most simple things in the Java language. All you have left are arrays, conditionals, and loops, which you'll learn about tomorrow. Then you'll learn how to define and use classes in Java applications on Day 6, and launch directly into applets next week. With just about everything you do in your Java programs, you'll always come back to objects.
<BR></P>
<H3><A ID = "I114" NAME = "I114"  >
<foNT SIZE=4><B>Q&amp;A</B>
<BR></FONT></A></H3>
<P><B>Q: I'm confused about the differences between objects and the primitive </B><B>data types, such as </B><B>int</B><B> and </B><B>boolean</B><B>.</B>
<BR></P>
<P><B>A: </B>The primitive types in the language (byte, short, int, long, float, double, boolean and char) represent the smallest things in the language. They are not objects, although in many ways they can be handled like objects&#151;they can be assigned to variables and passed in and out of methods. Most of the operations that work exclusively on objects, however, will not work on them.
<BR>
<BR>Objects are instances of classes and as such, are usually much more complex data types than simple numbers and characters, often containing numbers and characters as instance or class variables.
<BR></P>
<P><B>Q: In the section on calling methods, you had examples of calling a </B><B>method with a different number of arguments each time&#151;and it gave a </B><B>different kind of result. How is that possible?</B>
<BR></P>
<P><B>A: </B>That's called <I>method overloading.</I> Overloading enables the same function name to have different behavior based on the arguments it's called with&#151;and the number and type of arguments can vary. When you define methods in your own classes, you define separate method signatures with different sets of arguments and different definitions. When a method is called, Java figures out which definition to execute based on the number and type of arguments with which you called it.
<BR>
<BR>You'll learn all about this on Day 6.
<BR></P>
<P><B>Q: No operator overloading in Java? Why not? I thought Java was based on </B><B>C++, and C++ has operator overloading.</B>
<BR></P>
<P><B>A: </B>Java was indeed based on C++, but it was also designed to be simple, so many of C++'s features have been removed. The argument against operator overloading is that because the operator can be defined to mean anything, it makes it very difficult to figure out what any given operator is doing at any one time. This can result in entirely unreadable code. When you use a method, you know it can mean many things to many classes, but when you use an operator you would like to know that it always means the same thing. Given the potential for abuse, the designers of Java felt it was one of the C++ features that was best left out.
<BR></P>
<P><B><A HREF = "javascript:if(confirm('http://newdata.box.sk/bx/java/04tyj01.gif  \n\nThis file was not retrieved by Teleport Pro, because the server reports that this file cannot be found.  \n\nDo you want to open it from the server?'))window.location='http://newdata.box.sk/bx/java/04tyj01.gif'" tppabs="http://newdata.box.sk/bx/java/04tyj01.gif"  >Figure 4.1. References.</B></A></P>
<P><A HREF = "tyj03x.html" tppabs="http://newdata.box.sk/bx/java/tyj03x.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="blutoc.gif" tppabs="http://newdata.box.sk/bx/java/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF = "htindex.html" tppabs="http://newdata.box.sk/bx/java/htindex.html"  ><IMG SRC="bluindex.gif" tppabs="http://newdata.box.sk/bx/java/bluindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF = "tyj05x.html" tppabs="http://newdata.box.sk/bx/java/tyj05x.html"  ><IMG SRC="blunext.gif" tppabs="http://newdata.box.sk/bx/java/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF = "httoc.html" tppabs="http://newdata.box.sk/bx/java/httoc.html"  ><IMG SRC="bluprev.gif" tppabs="http://newdata.box.sk/bx/java/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Home"></A>
</P></BODY></HTML>
